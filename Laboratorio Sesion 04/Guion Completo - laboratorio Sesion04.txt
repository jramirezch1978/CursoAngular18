GUI칍N DETALLADO - SESI칍N 4: DIRECTIVAS - ANGULAR v18
PROVIAS DESCENTRALIZADO
________________________________________
Diapositiva 1: Portada del Curso (2 minutos)
춰Bienvenidos a nuestra cuarta sesi칩n del curso Angular 18! Es un placer verlos nuevamente aqu칤, listos para otra jornada de aprendizaje intensivo.
Mi nombre es Jhonny Alexander Ramirez Chiroque y hoy, jueves 7 de agosto de 2025, vamos a sumergirnos en el fascinante mundo de las Directivas. Si en las sesiones anteriores aprendimos a comunicar datos y transformarlos, hoy aprenderemos a controlar y manipular el DOM como verdaderos arquitectos de interfaces.
Las directivas son como los planos de construcci칩n de un edificio moderno. Imaginen que est치n dise침ando el nuevo centro de operaciones de PROVIAS. No solo necesitan que las puertas se abran y cierren, necesitan que se abran autom치ticamente cuando alguien se acerca, que cambien de color seg칰n el nivel de acceso, y que registren cada entrada. Eso es exactamente lo que hacen las directivas: agregan comportamiento inteligente a elementos simples.
Hoy la metodolog칤a ser치 completamente pr치ctica. Durante las pr칩ximas tres horas, sus manos estar치n en el teclado el 90% del tiempo. Es como aprender carpinter칤a: pueden leer todos los manuales del mundo, pero hasta que no tomen el martillo y los clavos, no construir치n nada real.
Angular 18 ha revolucionado las directivas con su nueva sintaxis de control flow. Los bloques @if, @for y @switch no son solo az칰car sint치ctico; son una reimaginaci칩n completa de c칩mo estructuramos nuestras aplicaciones. Y ustedes van a dominarlas hoy.
Preparen sus entornos de desarrollo, abran Visual Studio Code, aseg칰rense de que su proyecto Angular est칠 funcionando, y comencemos esta aventura pr치ctica juntos.
________________________________________
Diapositiva 2: Objetivos de la Sesi칩n (2 minutos)
Hoy no solo van a aprender sobre directivas; van a convertirse en maestros del control del DOM.
Dominar las directivas estructurales modernas es como aprender a ser el director de orquesta de su aplicaci칩n. Con @if, @for y @switch, van a decidir qu칠 elementos aparecen, cu치ndo aparecen, y c칩mo se organizan. Es el poder de hacer que su interfaz responda inteligentemente a los datos.
Las directivas de atributo son sus pinceles para pintar la interfaz. NgClass y NgStyle no son solo formas de cambiar colores; son herramientas para crear experiencias visuales que responden al estado de la aplicaci칩n. Imaginen un tablero de control donde los indicadores cambian de verde a rojo autom치ticamente cuando detectan problemas.
Crear directivas personalizadas complejas es donde se vuelven verdaderos artesanos. Van a construir comportamientos reutilizables que pueden aplicar a cualquier elemento. Es como crear sus propias herramientas especializadas que nadie m치s tiene.
HostListener y HostBinding son sus o칤dos y manos en el DOM. Con HostListener escuchan eventos: clicks, movimientos del mouse, teclas presionadas. Con HostBinding modifican propiedades: clases, estilos, atributos. Es interactividad en su m치xima expresi칩n.
Renderer2 es su guardaespaldas de seguridad. En lugar de manipular el DOM directamente (que es peligroso y puede causar vulnerabilidades), Renderer2 les proporciona m칠todos seguros que funcionan en cualquier plataforma, incluso en server-side rendering.
Las track functions son el secreto para aplicaciones ultrarr치pidas con listas grandes. Es la diferencia entre una aplicaci칩n que se congela con mil elementos y una que maneja millones sin pesta침ear.
Al final de esta sesi칩n, tendr치n un sistema completo con directivas que har칤an que cualquier desarrollador senior se sienta orgulloso.
________________________________________
Diapositiva 3: Agenda de la Sesi칩n (1 minuto)
Nuestra agenda est치 dise침ada como un entrenamiento militar: intenso, progresivo y altamente efectivo.
Los primeros 45 minutos del Lab 1 son los cimientos. Van a dominar la nueva sintaxis de control flow que Angular 17 y 18 han introducido. Es como aprender un nuevo idioma que es m치s claro, m치s eficiente y m치s poderoso.
El Lab 2 los llevar치 a las directivas de atributo avanzadas durante otros 45 minutos. Aqu칤 es donde la magia visual ocurre. Van a hacer que los elementos cambien din치micamente, respondan a interacciones, y se adapten al contexto.
Despu칠s de 90 minutos de c칩digo intenso, nos tomaremos un merecido break de 15 minutos. No lo subestimen; el cerebro necesita procesar toda la informaci칩n que est치n absorbiendo.
Al regresar, el Lab 3 es donde se vuelven creativos. Durante 45 minutos van a crear sus propias directivas personalizadas que resuelven problemas reales de negocio.
El Lab 4 es la cereza del pastel: 25 minutos de pura adrenalina implementando drag & drop y manipulaci칩n avanzada del DOM con Renderer2.
Los 칰ltimos 5 minutos consolidaremos todo lo aprendido y los prepararemos para llevar estas habilidades a sus proyectos reales.
________________________________________
Diapositiva 4: Evoluci칩n de Directivas en Angular 18 (3 minutos)
Lo que van a ver ahora es un antes y despu칠s en la historia de Angular.
La nueva sintaxis de control flow es como pasar de escribir en c칩digo morse a escribir en lenguaje natural. Miren este ejemplo: @if (isLoggedIn). 쯅o es hermosamente simple? No m치s asteriscos confusos, no m치s imports de CommonModule solo para un simple if.
La diferencia es profunda. La sintaxis legacy con *ngIf requer칤a que Angular procesara todo como directivas normales. La nueva sintaxis est치 integrada directamente en el compilador. Es como la diferencia entre traducir simult치neamente y hablar nativamente el idioma.
El @for con track es genial. Antes ten칤amos que escribir trackBy functions separadas. Ahora est치 integrado: @for (item of items; track item.id). Angular sabe exactamente c칩mo identificar cada elemento para optimizar el renderizado.
El @empty es una adici칩n brillante. Cu치ntas veces han tenido que escribir un *ngIf adicional solo para mostrar "No hay elementos"? Ahora est치 integrado en el mismo bloque. Es dise침o inteligente que entiende casos de uso reales.
El @switch es m치s limpio que nunca. En lugar de m칰ltiples *ngSwitchCase, ahora tienen @case que es m치s legible y m치s eficiente. Es como tener un panel de control con botones claramente etiquetados en lugar de c칩digos cr칤pticos.
El mejor beneficio: tree-shaking mejorado. El c칩digo no utilizado se elimina m치s eficientemente en el build de producci칩n. Sus aplicaciones ser치n m치s peque침as y m치s r치pidas. En un proyecto reciente, vi reducciones del 15% en el tama침o del bundle solo por cambiar a la nueva sintaxis.
Y s칤, la sintaxis legacy todav칤a funciona. Angular es retrocompatible. Pero como profesionales que somos, vamos a usar las herramientas m치s modernas y eficientes disponibles.
________________________________________
Diapositiva 5: Directivas Estructurales - Conceptos Core (3 minutos)
Las directivas estructurales son los arquitectos de su DOM. Deciden qu칠 existe y qu칠 no.
El @if con m칰ltiples condiciones es poderoso. Miren: @if (user && user.role === 'admin'). Est치n verificando no solo si el usuario existe, sino tambi칠n su rol. Es como un guardia de seguridad que verifica tanto el ID como el nivel de acceso antes de dejar pasar a alguien.
El @for con variables locales es una maravilla de dise침o. No solo iteran sobre elementos; tienen acceso a 칤ndices, primero, 칰ltimo, par, impar. Es como tener un GPS que no solo les dice d칩nde est치n, sino tambi칠n qu칠 hay alrededor.
La funci칩n track es cr칤tica para rendimiento. Imaginen una lista de 1000 empleados. Sin track, Angular recrea todos los elementos DOM cuando algo cambia. Con track, solo actualiza lo que realmente cambi칩. Es la diferencia entre reconstruir todo un edificio o solo repintar una habitaci칩n.
El @defer es futurista. Permite lazy loading a nivel de componente. Imaginen una p치gina con gr치ficos pesados. Con @defer (on viewport), el gr치fico solo se carga cuando el usuario lo va a ver. Es como tener un asistente que prepara las cosas justo cuando las necesitas, no antes.
El @placeholder mientras carga es UX profesional. En lugar de un espacio en blanco confuso, muestran un skeleton loader. Los usuarios saben que algo viene. Es la diferencia entre esperar en una sala vac칤a y esperar en una sala con una pantalla que muestra el progreso.
Estas directivas no solo modifican apariencia; modifican la estructura misma del DOM. Elementos entran y salen de existencia. Es poder real sobre la arquitectura de su aplicaci칩n.
________________________________________
Diapositiva 6: LAB 1 - Directivas Estructurales Modernas (5 minutos)
춰Manos a la obra! Vamos a construir un dashboard de usuarios que ser칤a la envidia de cualquier aplicaci칩n empresarial.
El componente UserDashboardComponent que van a crear es un ejemplo perfecto de c칩mo las directivas estructurales trabajan juntas. Imaginen que est치n construyendo el panel de control para los supervisores de PROVIAS, donde necesitan ver el estado de todos los trabajadores en campo en tiempo real.
Empezaremos con el @if para manejar estados de carga. Mientras los datos llegan del servidor, mostramos un spinner. Si hay un error, mostramos un mensaje de error claro. Si todo est치 bien, mostramos los usuarios. Es manejo de estados profesional.
El c칩digo es elegante en su simplicidad. @if (loading) muestra el spinner. No necesitan crear variables booleanas adicionales ni l칩gica compleja. Angular entiende que loading es un signal y reacciona autom치ticamente cuando cambia.
El @for con track user.id es crucial. Cada usuario tiene una tarjeta que muestra su informaci칩n. Pero aqu칤 viene lo interesante: el track asegura que si actualizan la lista (por ejemplo, un usuario cambia de estado), solo esa tarjeta espec칤fica se actualiza, no toda la lista.
El @switch para el estado del usuario es brillante. En lugar de m칰ltiples ifs anidados, tienen un switch limpio que muestra "En l칤nea", "Desconectado" o "Ausente" con diferentes colores. Es como los indicadores de un sem치foro: verde, gris, amarillo. Inmediatamente comprensible.
El @empty es el toque profesional. Si no hay usuarios, no muestran una pantalla vac칤a confusa. Muestran un mensaje claro: "No hay usuarios disponibles". Es cortes칤a b치sica con el usuario.
Los signals que usamos (users, loading, error) son la nueva forma reactiva de Angular. Cuando loading cambia a false, la vista se actualiza autom치ticamente. No necesitan detectores de cambios manuales ni subscripciones complicadas.
Durante estos 45 minutos, van a crear al menos 10 usuarios diferentes con estados variados. Van a simular cambios de estado en tiempo real y ver c칩mo las directivas responden instant치neamente. Van a agregar usuarios, eliminarlos, cambiar sus estados, y la interfaz se adaptar치 perfectamente.
Un tip importante: comiencen con datos hardcodeados para probar las directivas. Una vez que funcione, conecten con servicios reales. Es m치s f치cil debuggear cuando saben que el problema est치 en las directivas, no en los datos.
________________________________________
Diapositiva 7: Directivas de Atributo - NgClass y NgStyle (3 minutos)
Ahora entramos al mundo del estilizado din치mico. NgClass y NgStyle son sus varita m치gicas para transformar la apariencia.
NgClass con objetos es como tener un vestuario completo y decidir qu칠 ponerse seg칰n la ocasi칩n. El objeto que pasan determina qu칠 clases se aplican. 'active': isActive significa "si isActive es true, aplica la clase active". Es condicional puro y simple.
La sintaxis de array es 칰til cuando tienen clases base que siempre se aplican m치s clases din치micas. Es como tener un uniforme base y agregar insignias seg칰n los logros. ['base-class', dynamicClass] siempre aplica base-class y agrega lo que est칠 en dynamicClass.
NgStyle para estilos inline es potente pero 칰senlo con moderaci칩n. 'width.px': widthValue convierte autom치ticamente el n칰mero a p칤xeles. No necesitan concatenar 'px' manualmente. Angular lo hace por ustedes.
La transformaci칩n con rotate es genial para animaciones. 'transform': 'rotate(' + rotation + 'deg)' permite rotaci칩n din치mica. Imaginen un veloc칤metro digital donde la aguja se mueve seg칰n la velocidad. Eso es NgStyle en acci칩n.
La combinaci칩n con signals es el futuro. [ngClass]="themeClasses()" llama a una funci칩n computed que calcula las clases bas치ndose en m칰ltiples signals. Cuando cualquier signal cambia, las clases se recalculan autom치ticamente.
El tip de rendimiento es crucial: para c치lculos complejos, usen computed() de signals. En lugar de recalcular en cada detecci칩n de cambios, computed() solo recalcula cuando las dependencias cambian. Es la diferencia entre verificar constantemente si algo cambi칩 versus ser notificado cuando cambia.
La mejor pr치ctica de preferir clases CSS sobre estilos inline no es solo por limpieza. Las clases CSS son m치s eficientes, m치s f치ciles de mantener, y permiten mejor separaci칩n de responsabilidades. El CSS define c칩mo se ve algo; Angular decide cu치ndo aplicarlo.
________________________________________
Diapositiva 8: NgModel y Two-Way Binding (3 minutos)
NgModel es la joya del data binding bidireccional. Es como tener un espejo m치gico donde los cambios en cualquier lado se reflejan instant치neamente en el otro.
Primero, necesitan importar FormsModule. Es como obtener la licencia antes de conducir. Sin FormsModule, NgModel no funciona. Es un paso que muchos olvidan y luego se preguntan por qu칠 tienen errores.
El two-way binding b치sico [(ngModel)]="userName" es elegante. Los par칠ntesis cuadrados son para property binding (entrada), los par칠ntesis normales son para event binding (salida), y juntos forman la famosa "banana in a box". Cuando el usuario escribe, userName se actualiza. Cuando userName cambia en el c칩digo, el input se actualiza.
La descomposici칩n del banana-in-a-box es educativa. [ngModel]="email" (ngModelChange)="onEmailChange($event)" muestra lo que realmente sucede bajo el cap칩. Property binding establece el valor, event binding captura los cambios. Es 칰til cuando necesitan hacer algo adicional cuando el valor cambia, como validaci칩n en tiempo real.
Las validaciones con referencias de template son profesionales. #ageInput="ngModel" crea una referencia al estado del NgModel. Pueden verificar si es v치lido, tocado, pristine, dirty. Es como tener un inspector de calidad para cada campo.
El @if con validaciones es UX moderno. Solo muestran errores cuando el campo es inv치lido Y ha sido tocado. No abruman al usuario con errores antes de que tenga oportunidad de escribir. Es cortes칤a digital.
Los selects con NgModel son perfectos para opciones din치micas. El @for genera las opciones, NgModel mantiene la selecci칩n sincronizada. Cuando agregan o quitan opciones, todo sigue funcionando perfectamente.
La nota sobre Reactive Forms es importante. NgModel es genial para formularios simples y prototipos r치pidos. Pero para formularios complejos con validaciones avanzadas, validaciones as칤ncronas, o formularios din치micos, Reactive Forms es la herramienta profesional. Es como usar una calculadora b치sica versus Excel para finanzas.
________________________________________
Diapositiva 9: LAB 2 - Directivas de Atributo Avanzadas (5 minutos)
Este laboratorio es donde su aplicaci칩n se vuelve verdaderamente interactiva y personalizable. Van a construir un editor de temas que impresionar칤a hasta a los dise침adores m치s exigentes.
El ThemeEditorComponent que crearemos es como el panel de personalizaci칩n de un videojuego moderno, pero para su aplicaci칩n empresarial. Los usuarios podr치n cambiar temas, colores, tama침os, todo en tiempo real.
El panel de control es intuitivo. Un select para elegir el tema base (claro, oscuro, alto contraste). Es como los modos de lectura en los e-readers modernos. Cada modo optimizado para diferentes condiciones.
El input de color con [(ngModel)]="primaryColor" es satisfactorio. Mientras mueven el selector de color, toda la interfaz se actualiza instant치neamente. No hay bot칩n "aplicar", no hay retrasos. Es feedback instant치neo que hace que los usuarios sientan control total.
El slider para el tama침o de fuente es accesibilidad en acci칩n. No todos tienen la misma vista. Permitir ajustar el tama침o de fuente es inclusi칩n digital. El binding bidireccional hace que mientras mueven el slider, el texto crece o decrece en tiempo real.
El preview con m칰ltiples NgClass es donde la magia ocurre. Bas치ndose en isDarkMode, isCompact, hasAnimations, diferentes clases se aplican. Es como tener m칰ltiples personalidades para la misma interfaz.
El uso de CSS variables con NgStyle es moderno y eficiente. '--primary-color': primaryColor establece una variable CSS que luego puede ser usada en todo el CSS. Cambian un valor en Angular, y todo el tema se actualiza. Es arquitectura inteligente.
La combinaci칩n de ngClass con objetos din치micos y ngStyle con CSS variables es poderosa. NgClass maneja los cambios estructurales grandes (tema oscuro vs claro), NgStyle maneja los ajustes finos (colores espec칤ficos, tama침os).
Durante estos 45 minutos, van a implementar al menos 5 temas diferentes, permitir personalizaci칩n completa de colores, implementar persistencia en localStorage (para que las preferencias se mantengan), y agregar animaciones suaves entre cambios de tema.
Un detalle importante: usen transiciones CSS para que los cambios de tema no sean abruptos. transition: all 0.3s ease hace que los cambios sean suaves y profesionales, no jarring.
________________________________________
Diapositiva 10: BREAK (15 minutos)
춰Excelente trabajo! Han completado la primera mitad de nuestra sesi칩n intensiva de directivas.
En estos primeros 90 minutos han logrado cosas impresionantes. Han dominado la nueva sintaxis de control flow que est치 revolucionando Angular. Han implementado directivas de atributo que hacen que sus interfaces sean din치micas y responsivas.
Si comparamos con el mundo real, acaban de aprender a ser tanto arquitectos como decoradores de interiores. Pueden decidir qu칠 habitaciones existen (directivas estructurales) y c칩mo se ven (directivas de atributo).
Durante este break, les recomiendo que se levanten y estiren. El c칩digo intensivo puede tensar los hombros y el cuello. Hagan algunos estiramientos simples. Sus m칰sculos se los agradecer치n.
Tomen agua, no caf칠 en exceso. La hidrataci칩n mantiene el cerebro funcionando 칩ptimamente. El caf칠 est치 bien, pero el agua es esencial para mantener la concentraci칩n durante las pr칩ximas horas.
Si tienen errores en la consola, ahora es el momento de resolverlos. No dejen que se acumulen. Un error peque침o ahora puede convertirse en un dolor de cabeza grande despu칠s.
Reflexionen sobre lo que han aprendido. 쮺칩mo podr칤an usar estas directivas en sus proyectos actuales? Piensen en casos de uso reales. La mejor forma de solidificar el conocimiento es conectarlo con problemas que ya conocen.
La segunda mitad ser치 a칰n m치s emocionante. Van a crear sus propias directivas personalizadas. Es como pasar de usar herramientas prefabricadas a forjar las suyas propias. Van a usar HostListener para escuchar eventos, HostBinding para modificar propiedades, y Renderer2 para manipulaci칩n segura del DOM.
Prep치rense mentalmente. Lo que viene requiere creatividad adem치s de habilidad t칠cnica. Van a pensar en comportamientos reutilizables que pueden aplicar a cualquier elemento.
Nos vemos en exactamente 15 minutos, a las 20:45. 춰Descansen bien y regresen con energ칤a renovada!
________________________________________
Diapositiva 11: Directivas Personalizadas - Arquitectura (3 minutos)
Ahora entramos en territorio de ingenier칤a avanzada. Crear directivas personalizadas es como dise침ar sus propias herramientas especializadas.
La estructura de una directiva es elegante. El decorator @Directive define el selector, que es c칩mo la usar치n en los templates. [appTooltip] significa que es una directiva de atributo. Si fuera *appTooltip, ser칤a estructural.
Los @Input permiten parametrizaci칩n. appTooltip recibe el texto del tooltip, tooltipPosition define d칩nde aparece. Es como tener una herramienta ajustable que se adapta a diferentes situaciones.
@HostBinding es fascinante. Pueden modificar cualquier propiedad del elemento host. 'class.has-tooltip' agrega una clase, 'style.position' establece un estilo. Es control total sobre el elemento desde dentro de la directiva.
ElementRef les da acceso al elemento DOM nativo, pero aqu칤 viene la advertencia: nunca lo manipulen directamente. Es como tener acceso a los cables el칠ctricos de su casa; puede hacerlo, pero es peligroso.
Renderer2 es su herramienta segura. createElement, addClass, setProperty, appendChild - todos m칠todos que manipulan el DOM de forma segura, compatible con server-side rendering, y protegida contra XSS.
@HostListener es sus o칤dos en el DOM. 'mouseenter' y 'mouseleave' detectan cuando el mouse entra y sale. Pueden escuchar cualquier evento: clicks, teclas, scroll, resize, lo que necesiten.
La l칩gica de showTooltip es inteligente. Crea un div din치micamente, le agrega clases seg칰n la posici칩n, establece el texto, y lo agrega al elemento. Es creaci칩n din치mica de UI en su m치xima expresi칩n.
El patr칩n de crear y destruir elementos es importante para el rendimiento. No dejen elementos invisibles en el DOM; cr칠enlos cuando se necesiten, destr칰yanlos cuando no. Es gesti칩n eficiente de recursos.
________________________________________
Diapositiva 12: HostListener y HostBinding (3 minutos)
HostListener y HostBinding son sus superpoderes para interactuar con el elemento host. Son como tener control remoto total sobre cualquier elemento.
HostListener para eventos del mouse es lo b치sico. @HostListener('click', ['$event']) les da acceso al evento completo. Pueden saber exactamente d칩nde clickearon, qu칠 bot칩n usaron, si ten칤an teclas modificadoras presionadas. Es informaci칩n detallada para interacciones precisas.
El contador de clicks es 칰til para analytics. Pueden rastrear cu치ntas veces los usuarios interact칰an con elementos espec칤ficos. Es data valiosa para mejorar UX.
Los eventos de teclado abren posibilidades infinitas. @HostListener('keydown', ['$event']) detecta cualquier tecla. Pueden implementar atajos de teclado, navegaci칩n con flechas, comandos especiales. Es accesibilidad y productividad.
Los eventos de window son globales. 'window:resize' detecta cuando cambia el tama침o de la ventana. 칔til para layouts responsivos que necesitan recalcular dimensiones. Pero 칰senlo con moderaci칩n; los eventos globales pueden afectar el rendimiento.
HostBinding con clases es com칰n. @HostBinding('class.active') agrega o quita la clase 'active' bas치ndose en una variable booleana. Es m치s limpio que manipular classList manualmente.
El binding de estilos permite animaciones din치micas. style.backgroundColor puede cambiar bas치ndose en el estado. Imaginen botones que cambian de color seg칰n la validez del formulario.
Los getters con HostBinding son poderosos pero peligrosos. get transform() se ejecuta en cada detecci칩n de cambios. Para l칩gica simple est치 bien, pero c치lculos complejos matar치n el rendimiento.
El ejemplo del transform con scale es perfecto para hover effects. Cuando isHovered es true, el elemento crece a scale(1.1). Es feedback visual sutil pero efectivo que hace que la interfaz se sienta viva.
________________________________________
Diapositiva 13: LAB 3 - Directivas Personalizadas Complejas (5 minutos)
Este es el laboratorio m치s creativo. Van a construir tres directivas que resolver치n problemas reales que encuentran en cada proyecto.
La ValidationFeedbackDirective es oro puro para formularios. Imaginen que est치n validando datos de entrada para el sistema de PROVIAS. No solo necesitan validar; necesitan comunicar visualmente el estado de validaci칩n.
El HostBinding con getter para clases m칰ltiples es inteligente. Bas치ndose en el estado de validaci칩n, aplican diferentes clases: border-green para v치lido, border-red para inv치lido, border-yellow para pendiente. Es como un sem치foro para cada campo del formulario.
La clase 'shake' cuando hay error es UX delightful. El campo literalmente tiembla cuando hay un error, llamando la atenci칩n del usuario. Es feedback que no pueden ignorar.
La LazyLoadDirective resuelve un problema real de rendimiento. En lugar de cargar todas las im치genes al inicio (que puede ser lento), cargan solo las que est치n a punto de ser visibles. Es como un camarero que solo trae los platos cuando est치s listo para comerlos.
IntersectionObserver es API moderna del navegador. Detecta cuando un elemento entra en el viewport. Es m치s eficiente que escuchar eventos de scroll constantemente. Es la diferencia entre verificar constantemente versus ser notificado.
El placeholder mientras carga es profesional. Los usuarios ven una imagen de placeholder en lugar de un espacio vac칤o. Cuando la imagen real se carga, hace la transici칩n suavemente. Es la diferencia entre un sitio amateur y uno profesional.
La HasPermissionDirective es seguridad a nivel de UI. Bas치ndose en los permisos del usuario, elementos se muestran u ocultan. Es como tener diferentes versiones de la misma p치gina seg칰n el nivel de acceso.
El display: none es intencional. No solo oculta visualmente; remueve del layout completamente. Los usuarios no pueden acceder a elementos ocultos ni con inspect element (aunque la seguridad real debe estar en el backend).
Durante estos 45 minutos, van a implementar estas tres directivas y al menos dos m치s de su propia creaci칩n. Piensen en problemas repetitivos en sus proyectos. 쮽ormateo especial? 쮺omportamientos de UI espec칤ficos? Conviertan esos patrones en directivas reutilizables.
________________________________________
Diapositiva 14: Renderer2 - Manipulaci칩n Segura del DOM (3 minutos)
Renderer2 es su guardi치n de seguridad para manipulaci칩n del DOM. Es la diferencia entre cirug칤a con bistur칤 esterilizado versus con un cuchillo de cocina.
La manipulaci칩n directa del DOM es peligrosa. element.innerHTML puede introducir scripts maliciosos (XSS attacks). Es como dejar la puerta de su casa abierta. Renderer2 es su sistema de seguridad.
createElement es creaci칩n segura de elementos. No est치n parseando HTML strings que podr칤an contener c칩digo malicioso. Est치n creando elementos program치ticamente, con control total.
setAttribute vs setProperty es sutil pero importante. setAttribute establece atributos HTML, setProperty establece propiedades del DOM. La mayor칤a de las veces querr치n setProperty.
addClass y removeClass son m치s seguros que manipular className directamente. No sobrescriben accidentalmente otras clases. Es adici칩n y sustracci칩n precisa, no reemplazo total.
setStyle para estilos individuales es m치s eficiente que reemplazar todo el style. Cambian solo lo que necesitan cambiar. Es como ajustar un solo control en lugar de resetear todo el panel.
appendChild y removeChild para gesti칩n de elementos. Agregan elementos donde los necesitan, los quitan cuando terminan. Es gesti칩n limpia del DOM sin memory leaks.
El patr칩n de crear, usar y destruir es importante. El setTimeout que remueve el elemento despu칠s de 5 segundos muestra limpieza autom치tica. No dejen basura en el DOM.
listen para eventos es m치s poderoso que addEventListener. Retorna una funci칩n de cleanup que pueden llamar en ngOnDestroy. Es gesti칩n profesional de eventos sin memory leaks.
La ventaja de SSR compatibility es enorme para SEO. Renderer2 funciona tanto en el navegador como en el servidor. Su c칩digo es universal. Es futureproofing su aplicaci칩n.
________________________________________
Diapositiva 15: Directivas Estructurales Personalizadas (3 minutos)
Crear directivas estructurales propias es el nivel m치s alto de dominio Angular. Es como dise침ar nuevos bloques de construcci칩n para el lenguaje mismo.
La UnlessDirective es el ejemplo perfecto para entender c칩mo funcionan. Es lo opuesto a *ngIf. Muestra el contenido cuando la condici칩n es falsa. Es como una puerta que se abre cuando NO tienen la llave.
TemplateRef es la plantilla que el usuario defini칩. Es el contenido que quieren mostrar condicionalmente. ViewContainerRef es donde se insertar치 ese contenido. Es como tener el plano (template) y el terreno (container).
El patr칩n de hasView previene duplicaci칩n. Solo crean la vista si no existe, solo la destruyen si existe. Es gesti칩n de estado b치sica pero crucial para evitar bugs.
createEmbeddedView es donde la magia ocurre. Toma el template y lo convierte en elementos DOM reales. Es como imprimir en 3D desde un dise침o digital.
clear() remueve todo del container. Es limpieza total. 칔til cuando necesitan resetear completamente una secci칩n del DOM.
La ForWithIndexDirective muestra el poder del contexto. No solo pasan el item; pasan 칤ndice, primero, 칰ltimo, par, impar. Es informaci칩n rica que el template puede usar.
El objeto de contexto con $implicit es convenci칩n Angular. $implicit es el valor por defecto cuando usan let item. Los dem치s valores necesitan asignaci칩n expl칤cita: let i = index.
El caso de uso en templates es limpio. *appUnless="isLoggedIn" es inmediatamente comprensible. *appForWithIndex con todas las variables locales da control total sobre la iteraci칩n.
Estas directivas estructurales personalizadas son reutilizables across proyectos. Una vez creadas, se convierten en parte de su toolkit personal. Es inversi칩n en su futuro como desarrollador.
________________________________________
Diapositiva 16: LAB 4 - Host Binding y Renderer2 (5 minutos)
Este es el laboratorio final y m치s ambicioso. Van a implementar un sistema completo de drag & drop usando directivas.
El sistema de drag & drop que construiremos es como el que usan en Trello o Jira para mover tarjetas entre columnas. Pero lo har치n desde cero, entendiendo cada parte del proceso.
La DraggableDirective es comprehensiva. El @Input appDraggable permite activar/desactivar el comportamiento. No todos los elementos deben ser arrastrables todo el tiempo.
El @HostBinding('draggable') es HTML5 nativo. Le dice al navegador que este elemento puede ser arrastrado. Es la base sobre la cual construimos.
Los EventEmitters dragStart y dragEnd permiten que el componente padre reaccione. Cuando inicia el arrastre, pueden mostrar zonas de drop. Cuando termina, pueden actualizar el estado.
El binding de opacity durante el arrastre es feedback visual. El elemento se vuelve semi-transparente mientras lo arrastran. Los usuarios saben exactamente qu칠 est치n moviendo.
dataTransfer es el mecanismo de HTML5 para pasar datos durante el drag. setData guarda el ID del elemento. getData lo recupera en el drop. Es como un portapapeles temporal para la operaci칩n de arrastre.
El preview element con Renderer2 muestra manipulaci칩n avanzada. Crean un elemento de preview personalizado, lo posicionan fuera de vista, y lo usan como ghost image durante el arrastre.
La DropZoneDirective es el complemento perfecto. Define 치reas donde se pueden soltar elementos. El preventDefault() en dragover es crucial; sin 칠l, el navegador no permite el drop.
El highlight durante dragover es UX excelente. La zona de drop se ilumina cuando arrastran algo sobre ella. Los usuarios saben exactamente d칩nde pueden soltar.
El efecto de animaci칩n al soltar es el toque profesional. Crean un div temporal con clase 'drop-effect', que puede tener una animaci칩n CSS de ripple o glow, y lo remueven despu칠s de 500ms.
Durante estos 25 minutos, van a crear un kanban board funcional. Columnas para "Por hacer", "En progreso", "Completado". Tarjetas que se pueden arrastrar entre columnas. Estado que se actualiza correctamente. Persistencia en localStorage para que los cambios se mantengan.
________________________________________
Diapositiva 17: Optimizaci칩n y Performance (3 minutos)
La diferencia entre c칩digo que funciona y c칩digo profesional est치 en la optimizaci칩n.
Las track functions en @for son no negociables para listas grandes. Sin track, Angular no sabe qu칠 elementos son los mismos despu칠s de un cambio. Con track, Angular actualiza quir칰rgicamente solo lo que cambi칩. En una lista de 1000 items, puede ser la diferencia entre 16ms y 160ms de render time.
OnPush change detection es su mejor amigo para performance. Le dice a Angular: "solo verifica cambios en este componente si sus inputs cambian o si ocurre un evento". Reduce drasticamente los ciclos de detecci칩n de cambios.
Unsubscribe en ngOnDestroy es higiene b치sica. Cada suscripci칩n sin limpiar es un potential memory leak. Es como dejar luces encendidas cuando sales de casa. Use el patr칩n de takeUntil o async pipe para gesti칩n autom치tica.
Debounce para eventos frecuentes es crucial. Si escuchan scroll o resize sin debounce, su funci칩n puede ejecutarse cientos de veces por segundo. Con debounce de 200ms, se ejecuta m치ximo 5 veces por segundo. Es la diferencia entre matar el CPU y una experiencia fluida.
La manipulaci칩n directa del DOM debe evitarse siempre. innerHTML es inseguro y no portable. addEventListener sin cleanup causa memory leaks. Siempre usen Renderer2 y los m칠todos de Angular.
La l칩gica pesada en HostBinding getters es un error com칰n. Ese getter se ejecuta en cada detecci칩n de cambios. Si hace c치lculos complejos, su aplicaci칩n se arrastrar치. Usen signals con computed() o precalculen valores.
El memory leak con event listeners es insidioso. Cada listener sin limpiar es memoria que nunca se libera. En una SPA que vive por horas, pueden acumular megabytes de listeners zombies.
Renderer2 no es solo por seguridad; es por portabilidad. Su c칩digo funcionar치 en el navegador, en el servidor (SSR), en web workers, en cualquier plataforma que Angular soporte en el futuro.
________________________________________
Diapositiva 18: Casos de Uso Avanzados (2 minutos)
Veamos directivas del mundo real que pueden implementar ma침ana mismo en sus proyectos.
La SmartFocusDirective resuelve un problema com칰n: hacer focus en el campo correcto autom치ticamente. Con focusDelay pueden esperar a que animaciones terminen antes de hacer focus. Es UX pulida.
En formularios de login, hacer focus autom치tico en el campo de usuario mejora la experiencia. En modales, hacer focus en el primer campo acelera la entrada de datos. Son peque침os detalles que suman.
La InfiniteScrollDirective es essential para listas largas. En lugar de paginaci칩n tradicional (que requiere clicks), cargan m치s contenido autom치ticamente cuando el usuario llega al final. Es como Netflix o Instagram: scroll infinito sin fricci칩n.
El c치lculo atBottom es simple pero efectivo. Cuando scrollHeight - scrollTop equals clientHeight, est치n en el fondo. Emiten el evento, el componente carga m치s datos. Es elegante en su simplicidad.
La ClickOutsideDirective es perfecta para dropdowns y modales. Cuando el usuario clickea fuera, se cierra. Es comportamiento esperado en UIs modernas. Sin esta directiva, necesitar칤an l칩gica compleja en cada componente.
El document:click es evento global. Verifican si el click fue dentro o fuera del elemento. Si fue fuera, emiten el evento. El componente decide qu칠 hacer (cerrar, guardar, advertir).
Estos ejemplos no son te칩ricos. Los uso en cada proyecto. Son patrones que se repiten constantemente. Al convertirlos en directivas, escriben una vez, usan siempre. Es programaci칩n DRY en su m치xima expresi칩n.
________________________________________
Diapositiva 19: Testing de Directivas (2 minutos)
Testing de directivas es crucial pero a menudo ignorado. Hoy aprender치n a hacerlo correctamente.
El setup con TestBed es standard Angular testing. Configuran un m칩dulo de prueba, declaran un componente de prueba, crean la directiva. Es un ambiente controlado para testing.
By.directive es 칰til para encontrar elementos con la directiva aplicada. No buscan por clase o ID; buscan espec칤ficamente elementos que tienen la directiva. Es targeting preciso.
triggerEventHandler simula eventos. 'mouseenter' trigger el hover, 'mouseleave' lo quita. Pueden probar toda la interacci칩n sin browser real. Es testing automatizado y repetible.
fixture.detectChanges() es crucial. Le dice a Angular que ejecute detecci칩n de cambios. Sin esto, los cambios no se reflejan en el DOM de prueba. Es como presionar "refresh" en su test.
Las expectativas deben ser espec칤ficas. No solo verifiquen que "algo" cambi칩. Verifiquen el valor exacto. backgroundColor debe ser '#ffff00', no solo "alg칰n color". Es precisi칩n en testing.
El componente de prueba es minimalista. Solo incluye lo necesario para probar la directiva. No complican con l칩gica extra. Es testing focused y mantenible.
Los casos de prueba cubren el camino feliz y los edge cases. 쯈u칠 pasa si el color es undefined? 쯉i el elemento es null? 쯉i eventos se disparan m칰ltiples veces? Testing robusto previene bugs en producci칩n.
Este testing les ahorrar치 horas de debugging. Cuando algo falla, los tests les dicen exactamente qu칠 y d칩nde. Es inversi칩n en su sanidad mental futura.
________________________________________
Diapositiva 20: Q&A y Cierre (5 minutos)
춰Felicitaciones! Han completado una de las sesiones m치s intensas y productivas del curso.
Hoy han logrado algo remarkable. Han dominado el control flow moderno de Angular 18, esas directivas @if, @for, @switch que est치n revolucionando c칩mo escribimos aplicaciones. Ya no son principiantes tanteando en la oscuridad; son arquitectos del DOM.
Las directivas de atributo que implementaron van m치s all치 de cambiar colores. Han creado sistemas de temas din치micos, interfaces que responden inteligentemente al contexto, experiencias que se adaptan al usuario. Es la diferencia entre una aplicaci칩n y una experiencia.
Las directivas personalizadas que crearon son sus herramientas propias. Como un carpintero que fabrica sus propias herramientas especializadas, ahora tienen directivas que resuelven sus problemas espec칤ficos. Lazy loading, validaci칩n visual, permisos, drag & drop - son soluciones que pueden llevar a cualquier proyecto.
HostListener y HostBinding les han dado control quir칰rgico sobre el DOM. Pueden escuchar cualquier evento, modificar cualquier propiedad. Es poder que debe usarse responsablemente, y ustedes han aprendido a hacerlo.
Renderer2 les ha ense침ado la forma segura y profesional de manipular el DOM. No m치s innerHTML peligroso, no m치s manipulaci칩n directa arriesgada. Es c칩digo que puede correr en cualquier plataforma, resistente a ataques, profesional en todos los sentidos.
La optimizaci칩n con track functions y las mejores pr치cticas que aprendieron son la diferencia entre un desarrollador junior y uno senior. No es solo hacer que funcione; es hacer que funcione eficientemente, seguramente, manteniblemente.
La pr칩xima sesi칩n, el martes 12 de agosto, exploraremos el mundo de los M칩dulos, Componentes y Servicios. Si hoy aprendieron a controlar el DOM, la pr칩xima sesi칩n aprender치n a arquitectar aplicaciones completas. Inyecci칩n de dependencias avanzada, servicios singleton, la nueva arquitectura standalone que est치 cambiando Angular.
Como tarea opcional, les sugiero crear una directiva que resuelva un problema real en su trabajo. Tal vez una directiva de formateo para RUC peruanos, una directiva de autocompletado para direcciones de Lima, algo espec칤fico de su dominio. Ver치n c칩mo los conceptos de hoy se aplican inmediatamente.
Experimenten con TemplateRef y ViewContainerRef. Creen su propia directiva estructural. Tal vez una que muestre contenido basado en la hora del d칤a, o en el tipo de dispositivo. Sean creativos.
Preguntas frecuentes que suelen surgir:
"쮺u치ndo usar directivas vs componentes?" - Usen directivas para comportamiento reutilizable, componentes para UI reutilizable. Si es l칩gica sin template, directiva. Si tiene template propio, componente.
"쯃as nuevas directivas @if/@for son realmente mejores?" - S칤, mediblemente. Mejor tree-shaking, syntax m치s clara, mejor performance. No hay raz칩n para usar las antiguas en c칩digo nuevo.
"쯇uedo mezclar directivas antiguas y nuevas?" - T칠cnicamente s칤, pero no lo recomiendo. Mantengan consistencia en su codebase. Si migran, migren todo el componente.
"Renderer2 es realmente necesario?" - Para aplicaciones production-ready, absolutamente. Para prototipos r치pidos, pueden salirse con la suya. Pero desarrollen el h치bito correcto desde el inicio.
Para prepararse para la pr칩xima sesi칩n:
Revisen el concepto de inyecci칩n de dependencias. Es fundamental para entender servicios. Piensen en funcionalidad compartida en sus aplicaciones que podr칤a ser extra칤da a servicios.
Si tienen tiempo, experimenten con servicios simples. Creen uno que maneje el estado de usuario, otro que haga llamadas HTTP. Ver치n c칩mo los servicios organizan y centralizan la l칩gica.
Reflexi칩n final:
Hoy han dado un salto cu치ntico en sus habilidades Angular. Las directivas son el coraz칩n de Angular, y ustedes ahora entienden c칩mo late ese coraz칩n. Cada vez que vean una interfaz din치mica, pensar치n en directivas. Cada vez que necesiten comportamiento reutilizable, crear치n una directiva.
Recuerden: el mejor c칩digo es el que no tienen que escribir dos veces. Las directivas que crearon hoy son inversiones en su productividad futura. 칔senlas, comp치rtanlas, mej칩renlas.
Han sido tres horas intensas pero incre칤blemente productivas. Han pasado de usuarios de Angular a arquitectos de Angular. Est치n listos para enfrentar cualquier desaf칤o de UI que se les presente.
춰Excelente trabajo! Nos vemos el martes 12 de agosto a las 19:00 para continuar este viaje incre칤ble!
Descansen bien, practiquen lo aprendido, y vengan listos para el siguiente nivel.
춰Hasta la pr칩xima sesi칩n! 游

