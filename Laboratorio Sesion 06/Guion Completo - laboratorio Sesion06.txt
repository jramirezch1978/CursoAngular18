GUIÓN DETALLADO - SESIÓN 6: COMUNICACIÓN HTTP
PROVIAS DESCENTRALIZADO
________________________________________
Diapositiva 1: Carátula (2 minutos)
Muy buenas noches a todos y bienvenidos a nuestra sexta sesión del curso Angular 18. Es un placer verlos nuevamente en esta jornada de aprendizaje práctico e intensivo.
Mi nombre es Jhonny Alexander Ramirez Chiroque y hoy, jueves 14 de agosto de 2025, vamos a sumergirnos en uno de los aspectos más críticos del desarrollo web moderno: la comunicación HTTP. Si las sesiones anteriores les enseñaron a construir la estructura interna de sus aplicaciones, hoy aprenderán a conectarlas con el mundo exterior.
Imaginen que su aplicación Angular es como una oficina moderna en PROVIAS. Tienen empleados eficientes (componentes), procesos bien definidos (servicios), pero necesitan comunicarse con proveedores, clientes y otras oficinas. Eso es exactamente lo que haremos hoy: establecer esos canales de comunicación de forma profesional y robusta.
Esta sesión será completamente práctica, un laboratorio intensivo donde sus manos estarán constantemente en el teclado. No vamos a teorizar sobre HTTP; vamos a implementar sistemas reales de comunicación que podrán usar mañana mismo en sus proyectos.
Angular 18 con HttpClient y RxJS nos ofrece herramientas increíblemente poderosas para manejar comunicación asíncrona. Es como tener un equipo de mensajeros inteligentes que saben exactamente cómo entregar información, reintentar si algo falla, y optimizar las rutas para máxima eficiencia.
Preparen sus entornos, verifiquen que tienen una API REST disponible (usaremos JSON Server para simular), y prepárense para tres horas de código intensivo que transformarán sus aplicaciones de islas aisladas a sistemas conectados globalmente.
________________________________________
Diapositiva 2: Objetivos de la Sesión (2 minutos)
Los objetivos de hoy no son solo técnicos; son transformacionales para sus aplicaciones.
Dominar HttpClient es como aprender a conducir en una ciudad grande. Al principio parece complejo con tantas rutas y opciones, pero una vez que entienden los patrones, pueden navegar a cualquier destino eficientemente. HttpClient es su vehículo para comunicarse con cualquier API REST del mundo.
Implementar métodos HTTP correctamente es fundamental. GET para obtener datos, POST para crear, PUT para actualizar completo, PATCH para cambios parciales, DELETE para eliminar. Es como tener diferentes herramientas en una caja: cada una tiene su propósito específico y usar la incorrecta puede causar problemas.
El manejo de errores profesional separa las aplicaciones amateur de las empresariales. Sus usuarios no deberían ver mensajes crípticos como "Error 500". Van a aprender a traducir errores técnicos en mensajes comprensibles y acciones recuperables. Es como tener un traductor que convierte jerga técnica en español claro.
Los HTTP Interceptors son sus guardias de seguridad y auditores. Cada petición que sale y cada respuesta que entra pasa por ellos. Pueden agregar tokens de autenticación automáticamente, registrar toda la actividad, transformar datos. Es automatización inteligente que previene errores y mejora la seguridad.
La optimización con caching y retry strategies marca la diferencia entre una aplicación lenta y una instantánea. Van a aprender a guardar respuestas frecuentes, reintentar inteligentemente cuando algo falla, y hacer que su aplicación se sienta rápida incluso con conexiones lentas.
Trabajar con Observables y RxJS es entender programación reactiva. Es un cambio de paradigma: en lugar de pedir datos y esperar, crean flujos de datos que se actualizan automáticamente. Es como suscribirse a un periódico: no tienen que ir a buscarlo cada día, llega a su puerta automáticamente.
Al final de esta sesión, tendrán una aplicación que se comunica profesionalmente con APIs REST, maneja errores elegantemente, y optimiza cada petición para máximo rendimiento.
________________________________________
Diapositiva 3: Agenda (1 minuto)
Nuestra agenda está diseñada como una progresión lógica de habilidades, cada laboratorio construye sobre el anterior.
El Laboratorio 1 de 45 minutos es nuestra base sólida. Van a implementar un CRUD completo, los cuatro pilares de cualquier aplicación: Crear, Leer, Actualizar y Eliminar. Es como aprender los verbos básicos de un idioma antes de formar oraciones complejas.
El Laboratorio 2, también de 45 minutos, los convertirá en médicos de aplicaciones. Van a diagnosticar errores, prescribir soluciones, y crear una experiencia de usuario que no se rompe cuando las cosas salen mal. Porque créanme, las cosas saldrán mal, y estar preparados marca la diferencia.
Nuestro break de 15 minutos llegará en el momento perfecto, cuando sus cerebros necesiten procesar lo aprendido y sus manos necesiten descansar del teclado.
El Laboratorio 3 de 45 minutos es donde la magia sucede. Los interceptors son como tener asistentes invisibles que preparan todo antes de que lo necesiten. Autenticación automática, logging transparente, transformación de datos sin esfuerzo.
El Laboratorio 4 de 25 minutos es optimización pura. Van a hacer que su aplicación vuele con técnicas de caching y retry strategies. Es la diferencia entre un auto común y uno de carreras: ambos llegan al destino, pero la experiencia es completamente diferente.
Los últimos 5 minutos consolidaremos el conocimiento y los prepararemos para aplicar estas técnicas en el mundo real. Cada minuto cuenta, cada ejercicio tiene un propósito.
________________________________________
Diapositiva 4: LAB 1 - Introducción HttpClient (3 minutos)
Bienvenidos al primer laboratorio. Vamos a construir algo real: un sistema completo de gestión de productos.
Lo que construiremos no es un ejemplo de juguete. Es un sistema que cualquier empresa de comercio electrónico necesitaría. Imaginen que PROVIAS decide vender equipos de construcción en línea. Necesitan listar productos, agregar nuevos, actualizar precios, eliminar descontinuados. Eso es exactamente lo que implementaremos.
El CRUD completo que desarrollaremos es el fundamento de casi cualquier aplicación web. Es como aprender a cocinar los platos básicos: una vez que dominan estos, pueden crear cualquier combinación. Create para agregar productos nuevos cuando llega inventario. Read para mostrar el catálogo. Update cuando cambian precios o descripciones. Delete cuando un producto se descontinúa.
Los Observables para manejo asíncrono son cruciales porque las llamadas HTTP no son instantáneas. Es como pedir comida a domicilio: no se quedan esperando en la puerta, hacen otras cosas y reaccionan cuando llega. Los Observables les permiten ese mismo patrón en código.
El tipado fuerte con interfaces TypeScript es su red de seguridad. Define exactamente qué estructura tienen sus productos: nombre, precio, categoría, stock. TypeScript les avisará si intentan acceder a una propiedad que no existe o si envían datos mal formados. Es como tener un revisor de contratos que verifica que todo esté en orden antes de firmar.
La configuración inicial con provideHttpClient es simple pero fundamental. Sin esto, su aplicación no puede hacer peticiones HTTP. Es como darle a su aplicación un teléfono para comunicarse con el mundo exterior. Una línea de código que habilita infinitas posibilidades.
________________________________________
Diapositiva 5: LAB 1 - Servicio HTTP Base (5 minutos)
Ahora vamos a implementar nuestro ProductService, el corazón de la comunicación con nuestra API.
Observen cómo estructuramos el servicio. Primero, la interfaz Product define nuestro contrato de datos. Es como un formulario estándar que todos deben llenar. El id es opcional porque cuando creamos un producto nuevo, aún no tiene id; el servidor lo asignará. Los demás campos son obligatorios: nombre, precio, descripción, categoría y stock.
El decorador Injectable con providedIn root hace que este servicio esté disponible globalmente. Es como tener un departamento de compras centralizado en la empresa: todos los departamentos pueden usarlo, hay una sola instancia, es eficiente.
La inyección de HttpClient con inject es la forma moderna de Angular 18. Más limpia que el constructor injection, más flexible. HttpClient es su herramienta de comunicación, como tener acceso a internet en su computadora.
El método getProducts muestra algo poderoso: parámetros opcionales. Si pasan una categoría, filtran por ella; si no, obtienen todos los productos. Es como ir al supermercado: pueden ir directo al pasillo de lácteos o recorrer toda la tienda.
HttpParams es la forma correcta de agregar parámetros de consulta. No concatenen strings manualmente; es propenso a errores y problemas de seguridad. HttpParams maneja la codificación, escapa caracteres especiales, construye la URL correctamente. Es como usar un GPS en lugar de preguntar direcciones: más confiable, menos errores.
El tipo de retorno Observable<Product[]> es explícito y seguro. Le dice a TypeScript y a otros desarrolladores exactamente qué esperan recibir. No es "algún dato", es específicamente un array de productos. Esta claridad previene bugs y hace el código autodocumentado.
El método getProduct por ID es aún más simple. Usan template literals para construir la URL dinámicamente. Es moderno, legible, y maneja la concatenación automáticamente. Cuando necesitan el producto con ID 123, la URL se convierte en api.example.com/products/123.
________________________________________
Diapositiva 6: LAB 1 - Métodos POST, PUT, DELETE (5 minutos)
Completemos nuestro CRUD con los métodos que modifican datos. Estos son los que realmente hacen que su aplicación sea interactiva.
El método createProduct con POST es como llenar un formulario de nuevo empleado. Envían todos los datos del producto (sin ID porque aún no existe), y el servidor responde con el producto creado, ahora con su ID asignado. Es creación pura.
Noten los headers personalizados. Content-Type application/json le dice al servidor que estamos enviando JSON. X-Requested-With XMLHttpRequest es una convención que algunos servidores usan para identificar peticiones AJAX. Son como poner el remitente en un sobre: información adicional que ayuda al destinatario.
updateProduct con PUT es reemplazo total. Envían el producto completo con todos sus campos. Es como reescribir un documento completo en lugar de hacer correcciones. Útil cuando tienen todos los datos y quieren asegurar consistencia.
patchProduct es más quirúrgico. Con Partial<Product>, solo envían los campos que cambiaron. Si solo actualizaron el precio, solo envían el precio. Es eficiente en ancho de banda y más claro en intención. Es como enviar una fe de erratas en lugar de reimprimir todo el libro.
deleteProduct es simple pero poderoso. No necesita body, solo el ID. El tipo de retorno es void porque no esperamos datos de vuelta, solo confirmación de que se eliminó. Es como triturar un documento: la acción es lo importante, no necesitan los pedazos de vuelta.
searchProducts muestra un patrón común: construcción dinámica de parámetros. El bucle que itera sobre los filtros y los agrega a los parámetros es elegante. Si tienen 10 filtros posibles pero solo usan 3, solo envían esos 3. Es eficiencia en comunicación.
Cada método retorna un Observable. Esto permite a los componentes decidir cómo manejar la respuesta: pueden suscribirse, pueden transformar con pipe, pueden combinar con otros observables. Es flexibilidad máxima.
________________________________________
Diapositiva 7: Observables vs Promises (3 minutos)
Esta comparación es crucial porque muchos vienen del mundo de las Promesas y necesitan entender por qué Angular usa Observables.
Las Promesas son como pedir una pizza: hacen el pedido, esperan, y reciben una pizza. Un pedido, una entrega. Simple, directo, pero limitado. Si quieren cancelar después de ordenar, mala suerte. Si quieren pedir una pizza cada viernes, necesitan hacer un nuevo pedido cada vez.
Los Observables son como una suscripción a un servicio de streaming. Pueden pausar, cancelar, reanudar. Pueden recibir múltiples valores a lo largo del tiempo. Pueden transformar lo que reciben antes de consumirlo. Es un paradigma más poderoso y flexible.
La característica "Lazy" de los Observables es fascinante. Una Promesa se ejecuta inmediatamente cuando la crean. Un Observable no hace nada hasta que alguien se suscribe. Es como la diferencia entre cocinar especulando que alguien tendrá hambre versus cocinar cuando alguien pide comida. Eficiencia de recursos.
La cancelación es crítica en aplicaciones reales. Usuario escribe en un buscador, cada letra genera una petición. Con Promesas, todas se ejecutan. Con Observables y switchMap, cada nueva búsqueda cancela la anterior. Es como cuando llaman a un call center y cuelgan si tarda mucho: con Observables, el operador sabe que colgaron y no pierde tiempo respondiendo.
Los más de 100 operadores de RxJS son como tener una navaja suiza gigante. retry para reintentar, debounceTime para esperar que el usuario termine de escribir, map para transformar datos, filter para filtrar, catchError para manejar errores. Cada operador resuelve un problema común elegantemente.
El ejemplo práctico muestra la diferencia. Con Promesas, manejo básico de errores, sin reintentos, sin transformación elegante. Con Observables, reintentan 3 veces automáticamente, filtran productos sin stock, cachean el resultado. Es la diferencia entre un martillo y una caja de herramientas completa.
________________________________________
Diapositiva 8: LAB 2 - Introducción Manejo de Errores (3 minutos)
El segundo laboratorio los convertirá en expertos en manejo de crisis. Porque en el mundo real, las cosas fallan.
Los errores HTTP no son solo números; cuentan historias. Un 404 dice "no encontré lo que buscas". Un 401 dice "no sé quién eres". Un 500 dice "algo salió mal de mi lado". Entender estos códigos es como aprender a leer señales de tránsito: vital para navegar correctamente.
Los timeouts y pérdida de conexión son realidades de la vida moderna. Un usuario en el metro puede perder señal. Un servidor puede estar sobrecargado. Su aplicación no debe colapsar; debe manejar estas situaciones con gracia. Es como tener un plan B cuando el plan A falla.
El retry automático con backoff es inteligencia aplicada. Primera falla: reintentar inmediatamente. Segunda: esperar un segundo. Tercera: esperar dos segundos. Es como tocar una puerta: primero suave, si no responden, un poco más fuerte, pero no se quedan tocando frenéticamente.
Los loading states son comunicación con el usuario. Nadie quiere mirar una pantalla congelada sin saber si algo está pasando. Un simple spinner dice "estoy trabajando en eso". Es cortesía básica en UX, como decir "un momento por favor" cuando alguien espera.
Las notificaciones al usuario completan el círculo. "Producto guardado exitosamente", "Error al cargar datos", "Sin conexión a internet". Mensajes claros, no técnicos, accionables. Es la diferencia entre un sistema que frustra y uno que guía.
Las interfaces ApiError y ValidationError que definimos no son solo tipos; son contratos de comunicación entre frontend y backend. Cuando algo falla, saben exactamente qué información recibirán. Es como tener un formato estándar para reportes de incidentes: todos saben qué esperar.
________________________________________
Diapositiva 9: LAB 2 - Implementación Error Handler (5 minutos)
Vamos a implementar un servicio robusto de manejo de errores que será su red de seguridad.
El ErrorHandlerService es como el departamento de atención al cliente de su aplicación. Cuando algo sale mal, interviene, analiza el problema, y comunica apropiadamente. No es solo capturar errores; es gestionarlos inteligentemente.
La distinción entre errores del cliente y del servidor es crucial. ErrorEvent indica problemas del lado del cliente: sin conexión, CORS, problemas de red. HttpErrorResponse indica que el servidor respondió con un error. Es como distinguir entre "no puedo llamar" y "me respondieron que no". Diferentes problemas requieren diferentes soluciones.
El método getServerErrorMessage traduce códigos HTTP a mensajes humanos. Un 401 no significa nada para un usuario normal, pero "No autorizado. Por favor inicie sesión" es claro y accionable. Es como tener un traductor técnico-español en su equipo.
La inyección del NotificationService muestra separación de responsabilidades. El error handler identifica y categoriza el error, el notification service lo comunica al usuario. Es como tener un detective que encuentra el problema y un vocero que lo explica. Cada uno experto en su área.
El patrón de re-throw del error transformado es poderoso. No se tragan el error silenciosamente; lo transforman en algo más útil y lo pasan adelante. Los componentes pueden decidir si necesitan manejo adicional. Es transparencia con valor agregado.
El switch statement para diferentes códigos de error es extensible. Pueden agregar casos específicos para su aplicación. Si el código 409 significa "conflicto de versiones" en su API, pueden agregar un mensaje específico. Es personalización basada en necesidades reales.
El timestamp en el error transformado es útil para debugging. Cuando un usuario reporta un problema, pueden correlacionar con logs del servidor. "El error ocurrió a las 15:42:07" es más útil que "hubo un error". Es trazabilidad profesional.
________________________________________
Diapositiva 10: LAB 2 - Loading States (5 minutos)
Los estados de carga son la diferencia entre una aplicación que se siente rápida y una que parece colgada.
El LoadingService con Map para múltiples requests es ingenioso. No es solo un booleano global de "cargando" o "no cargando". Pueden rastrear múltiples peticiones simultáneas. Es como tener un tablero de control que muestra el estado de cada operación.
El signal para el estado de loading es reactive programming moderno. Cuando cambia, todos los componentes que lo observan se actualizan automáticamente. No necesitan notificar manualmente; es propagación automática. Es como tener un semáforo que todos pueden ver.
El método setLoading con URL opcional da flexibilidad. Pueden tener un loading global para toda la aplicación o loading específico por operación. Es como tener un indicador general de "oficina ocupada" y luces individuales en cada escritorio.
La lógica de verificar si hay peticiones pendientes es elegante. Solo mientras el Map tenga entradas, el loading global está activo. Cuando la última petición termina, el loading se apaga automáticamente. Es gestión inteligente sin intervención manual.
En el ProductService mejorado, vean cómo integran loading con las peticiones. Activan loading al iniciar, lo desactivan con finalize. finalize se ejecuta sin importar si la petición fue exitosa o falló. Es limpieza garantizada, como un finally en try-catch.
El patrón de usar la URL como clave es identificación única natural. Cada endpoint tiene su propio estado de loading. Pueden mostrar spinners específicos: "Cargando productos..." vs "Guardando cambios...". Es feedback granular que mejora la experiencia.
La integración con el error handler muestra arquitectura en capas. Loading maneja estado de carga, error handler maneja errores, cada servicio se enfoca en su responsabilidad. Es como departamentos especializados que colaboran sin pisarse los pies.
________________________________________
Diapositiva 11: LAB 2 - Retry Strategies (5 minutos)
Las estrategias de reintento inteligente son lo que separa aplicaciones amateur de profesionales.
La función retryWithBackoff implementa un patrón conocido como "exponential backoff". Es como cuando llaman a alguien ocupado: primero esperan un minuto, luego dos, luego cuatro. No insisten cada segundo como un acosador. Es cortesía algorítmica.
El operador scan acumula el conteo de reintentos. Es memoria de cuántas veces han intentado. Cuando llegan al máximo, se rinden y propagan el error. Es saber cuándo parar, no insistir infinitamente. Como dice el refrán: "El que persevera alcanza", pero también hay que saber cuándo soltar.
El cálculo del delay con backoff exponencial es matemática aplicada. Primer reintento: 1 segundo. Segundo: 2 segundos. Tercero: 4 segundos. Pero con un máximo para no esperar eternamente. Es balance entre persistencia y practicidad.
Los console.log durante reintentos no son solo debugging; son transparencia. Los desarrolladores (y en producción, los logs) pueden ver qué está pasando. "Reintento #2... Esperando 2000ms". Es visibilidad del proceso, no una caja negra.
El operador tap para logging no modifica el flujo de datos, solo observa. Es como tener cámaras de seguridad: ven todo pero no interfieren. Útil para debugging sin afectar la lógica.
El método getProductsWithRetry muestra integración práctica. No todos los métodos necesitan retry. Un DELETE fallido tal vez no debería reintentarse automáticamente. Un GET de solo lectura sí. Es aplicar retry selectivamente donde tiene sentido.
La combinación con catchError asegura que si todos los reintentos fallan, aún manejan el error apropiadamente. No es retry ciego; es retry con red de seguridad. Es como tener un paracaídas de emergencia además del principal.
________________________________________
Diapositiva 12: BREAK (15 minutos)
Excelente trabajo hasta aquí. Han completado la mitad de nuestra sesión y han logrado cosas impresionantes.
Han implementado un HttpClient completo con todos los métodos HTTP. Ya no están limitados a solo leer datos; pueden crear, actualizar y eliminar. Su aplicación ahora puede interactuar completamente con cualquier API REST. Es como pasar de solo leer libros a poder escribirlos y editarlos.
El manejo de errores profesional que configuraron es su escudo contra los problemas inevitables. Los usuarios verán mensajes claros, no errores crípticos. Las peticiones se reintentan inteligentemente. Es la diferencia entre una aplicación que colapsa y una que se recupera con gracia.
Los loading states implementados hacen que su aplicación se sienta viva y responsiva. Los usuarios saben que algo está pasando, no se quedan mirando una pantalla congelada preguntándose si deben recargar. Es comunicación continua que genera confianza.
Las retry strategies con backoff son optimización inteligente. No bombardean el servidor con reintentos; esperan progresivamente más. Es ser un buen ciudadano de internet, respetuoso con los recursos del servidor.
Durante este break, levántense y caminen un poco. El código intensivo puede tensar el cuerpo sin que se den cuenta. Estiren los brazos, roten los hombros, den unos pasos. Su cuerpo se lo agradecerá.
Hidrátense bien. El cerebro consume mucha energía cuando están concentrados programando. Agua, jugo, lo que prefieran, pero manténganse hidratados. La segunda mitad será aún más intensa.
Reflexionen sobre lo aprendido. ¿Cómo pueden aplicar este manejo de errores en sus proyectos actuales? ¿Dónde les serviría el retry con backoff? Conectar el conocimiento nuevo con necesidades reales lo solidifica.
Lo que viene después del break es emocionante: Interceptors para automatizar tareas comunes, caching para hacer su aplicación instantánea, optimizaciones que marcarán la diferencia. Prepárense mentalmente para el siguiente nivel.
Nos vemos en exactamente 15 minutos, a las 20:45. Regresen con energía renovada y listos para la segunda mitad. ¡Lo están haciendo genial!
________________________________________
Diapositiva 13: LAB 3 - Introducción a Interceptors (3 minutos)
Bienvenidos de vuelta. Los Interceptors son una de las características más poderosas y elegantes de Angular HTTP.
Piensen en los interceptors como guardias de seguridad y asistentes en la entrada de un edificio. Cada persona que entra (request) y sale (response) pasa por ellos. Pueden verificar identificación, agregar badges, registrar en bitácora, transformar paquetes. Todo automáticamente, sin que los visitantes (componentes) tengan que hacer nada especial.
La capacidad de agregar tokens de autenticación automáticamente es revolucionaria. Sin interceptors, tendrían que acordarse de agregar el token en cada petición. Con interceptors, lo hacen una vez y funciona para toda la aplicación. Es como tener una tarjeta de acceso que automáticamente abre todas las puertas, sin tener que mostrarla cada vez.
El logging de requests y responses es auditoría automática. Pueden ver cada petición que sale, cada respuesta que llega, cuánto tardó, si hubo errores. En desarrollo es invaluable para debugging. En producción, es evidencia forense cuando algo sale mal.
La transformación de datos elimina código repetitivo. Si su backend envía fechas como strings y necesitan Date objects, el interceptor puede convertirlas automáticamente. Es como tener un traductor que convierte automáticamente del formato del backend al formato que necesita el frontend.
La medición de tiempos de respuesta les da métricas de rendimiento gratis. Sin escribir código adicional en cada servicio, pueden saber qué endpoints son lentos, cuáles son rápidos, dónde optimizar. Es telemetría integrada sin esfuerzo.
El flujo bidireccional es importante de entender. Los interceptors procesan requests de salida en orden, y responses de entrada en orden inverso. Es como las capas de una cebolla: entran por una capa a la vez, y salen en orden inverso.
La configuración con functional interceptors es la forma moderna en Angular 15+. Más simple que las clases, más fácil de testear, más flexible. Es evolución del framework respondiendo a feedback de la comunidad.
________________________________________
Diapositiva 14: LAB 3 - Auth Interceptor (5 minutos)
El interceptor de autenticación es probablemente el más común y útil que implementarán.
La función authInterceptor que estamos creando es elegancia pura. No es una clase complicada; es una función simple que toma una petición y la siguiente función en la cadena. Es programación funcional aplicada.
El inject(AuthService) dentro del interceptor muestra la flexibilidad del nuevo sistema de inyección. Pueden inyectar servicios donde los necesiten, no solo en constructores. Es acceso a servicios bajo demanda.
La lista de URLs públicas es seguridad inteligente. No quieren agregar un token de autenticación cuando alguien está tratando de hacer login. Sería como pedir identificación para obtener una identificación. El interceptor es suficientemente inteligente para saber cuándo no intervenir.
El patrón de clonar la request es crucial. Las requests en Angular son inmutables; no pueden modificarlas directamente. Deben clonar y modificar el clon. Es como el principio de inmutabilidad que vimos con signals: previene efectos secundarios inesperados.
El header Authorization con Bearer token es el estándar de la industria. Bearer significa "portador"; quien porta este token tiene autorización. Es como un pase VIP: quien lo muestra, entra.
El AuthService con signal para el token es estado reactivo moderno. Cuando el token cambia, todo lo que lo observa se actualiza. Login actualiza el token, logout lo limpia, y el interceptor siempre usa el valor actual.
El respaldo a localStorage asegura persistencia. Si el usuario recarga la página, el token no se pierde. Pero el signal tiene prioridad para cambios en tiempo real. Es lo mejor de ambos mundos: persistencia y reactividad.
El patrón de "skip para rutas públicas" es extensible. Pueden agregar más rutas, pueden verificar otros criterios. Tal vez algunas rutas necesitan un token diferente, o no necesitan autorización pero sí logging. Es flexibilidad para casos reales.
________________________________________
Diapositiva 15: LAB 3 - Logging Interceptor (5 minutos)
El interceptor de logging es su caja negra de vuelo. Cuando algo sale mal, aquí encontrarán las respuestas.
El registro del timestamp inicial con Date.now() es el inicio del cronómetro. Van a medir cuánto tarda cada petición. En desarrollo, ayuda a identificar endpoints lentos. En producción, es métrica de rendimiento.
El console.group crea una sección colapsable en la consola. Toda la información de una petición está agrupada visualmente. Es organización que facilita el debugging cuando tienen docenas de peticiones simultáneas.
Registrar headers y body no es voyeurismo; es transparencia necesaria. ¿Se envió el token correctamente? ¿El body tiene la estructura esperada? Sin esto, debuggear problemas de API es como buscar una aguja en un pajar a oscuras.
El operador tap con next y error maneja ambos casos. Peticiones exitosas y fallidas, ambas se registran. Es cobertura completa, no solo los casos felices. Como dice el dicho: "Espera lo mejor, prepárate para lo peor".
El finalize es garantía de ejecución. Sin importar si la petición fue exitosa, falló, o fue cancelada, el tiempo se registra. Es como el finally en try-catch: siempre se ejecuta.
El cálculo del tiempo transcurrido y el formato del mensaje es UX para desarrolladores. "GET /api/products OK en 234ms" es inmediatamente comprensible. No necesitan hacer matemáticas mentales.
Los emojis (✅ para éxito, ❌ para error) no son decoración; son identificación visual rápida. En una consola con cientos de líneas, pueden identificar problemas de un vistazo. Es diseño de información aplicado.
El LoggingService para producción es evolución natural. En desarrollo, console.log está bien. En producción, necesitan enviar logs a un servidor para análisis. El patrón de acumular y enviar en lotes es eficiencia: no hacen una petición por cada log.
________________________________________
Diapositiva 16: LAB 3 - Transform Interceptor (5 minutos)
Los interceptors de transformación son sus traductores universales entre el mundo del backend y el frontend.
El transformInterceptor estandariza respuestas. No todos los backends siguen la misma estructura. Algunos envían datos directamente, otros los envuelven en un objeto data, otros incluyen metadata. Este interceptor normaliza todo a una estructura consistente.
La verificación instanceof HttpResponse es importante. No todas las emisiones del observable son respuestas completas. Algunas son eventos de progreso, otras son headers parciales. Solo transforman las respuestas finales.
La estructura estandarizada con data y meta es un patrón común. data contiene los datos reales, meta contiene información sobre la respuesta: timestamp, versión de API, estado. Es separación clara entre datos y metadata.
El clone con body transformado mantiene inmutabilidad. No modifican la respuesta original; crean una nueva con el body transformado. Es el mismo principio que con requests: inmutabilidad previene bugs sutiles.
El dateInterceptor es un caso de uso específico pero común. Los backends típicamente envían fechas como strings ISO. JavaScript necesita objetos Date. Este interceptor hace la conversión automáticamente.
La función recursiva convertDates es thoroughness. No solo convierte fechas en el nivel superior; busca en todo el objeto, en arrays, en objetos anidados. Es conversión completa, no superficial.
La función isIsoDateString (no mostrada pero implícita) usa regex para identificar strings de fecha. Algo como /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/ identifica el formato ISO. Es pattern matching aplicado.
El beneficio de esta transformación automática es código más limpio en componentes. No necesitan recordar convertir fechas, no necesitan verificar tipos. Reciben datos listos para usar. Es la promesa de los interceptors: automatización de tareas repetitivas.
________________________________________
Diapositiva 17: LAB 4 - Introducción a Caching (3 minutos)
El último laboratorio es sobre hacer su aplicación volar. El caching bien implementado puede hacer que su aplicación se sienta instantánea.
El Memory Cache es velocidad pura. Los datos están en la RAM, el acceso es inmediato. Perfecto para datos que se usan frecuentemente en una sesión. Es como tener los documentos más usados sobre el escritorio en lugar del archivo.
IndexedDB para grandes volúmenes es persistencia con capacidad. Pueden guardar megabytes de datos que sobreviven recargas de página. Es como tener un almacén local en lugar de pedir todo del almacén central cada vez.
TTL (Time To Live) es frescura garantizada. Los datos de hace 5 minutos pueden estar bien, los de hace una hora tal vez no. Es como la fecha de vencimiento en productos: después de cierto tiempo, mejor obtener frescos.
Cache Invalidation, dicen, es uno de los dos problemas más difíciles en computación (el otro es nombrar cosas). ¿Cuándo limpiar el cache? ¿Cuándo actualizarlo? Sus estrategias aquí determinarán si el cache ayuda o confunde.
El ejemplo visual muestra el impacto. Sin cache, tres componentes hacen tres peticiones al servidor. Con cache, la primera petición se guarda y los otros dos componentes usan esa copia. Es reducción del 66% en tráfico de red.
El balance es crucial. Demasiado cache y los usuarios ven datos viejos. Muy poco cache y desperdician oportunidades de optimización. Es como encontrar el punto justo de cocción: ni crudo ni quemado.
________________________________________
Diapositiva 18: LAB 4 - Implementación de Cache Service (5 minutos)
Vamos a implementar un servicio de cache robusto y flexible.
El CacheService con Map es elección inteligente. Map es más eficiente que objetos plain para muchas operaciones, mantiene orden de inserción, acepta cualquier tipo como clave. Es la estructura de datos correcta para este trabajo.
La interface CacheEntry con response y timestamp es información completa. No solo guardan la respuesta; guardan cuándo la guardaron. Es como etiquetar frascos en la nevera con la fecha: saben cuándo algo es muy viejo.
El método get con verificación de expiración es frescura garantizada. No solo verifican si existe en cache; verifican si sigue siendo válido. Datos expirados son peores que no tener datos. Es control de calidad automático.
La decisión de solo cachear GET exitosos es sentido común. No quieren cachear errores. No quieren cachear operaciones que modifican datos. GET es lectura, es seguro cachear. POST, PUT, DELETE modifican estado, cachearlos causaría inconsistencias.
El clone de la respuesta antes de cachear es crucial. Las respuestas HTTP solo pueden ser leídas una vez. Si guardan la original, el componente no puede leerla. Clonar permite que ambos tengan su copia. Es como fotocopiar un documento antes de archivarlo.
La limpieza automática cuando el cache crece es mantenimiento preventivo. No quieren que el cache crezca infinitamente y consuma toda la memoria. Limpiar entradas expiradas periódicamente mantiene el cache eficiente.
El método clear con patrón opcional da control fino. Pueden limpiar todo el cache o solo entradas que coinciden con un patrón. Útil cuando actualizan un producto y quieren invalidar solo el cache de ese producto, no todo.
La clave compuesta METHOD:URL es identificación única. GET /products y POST /products son operaciones diferentes, deben tener entradas de cache separadas. Es precisión en identificación.
________________________________________
Diapositiva 19: LAB 4 - Cache Interceptor (5 minutos)
El cache interceptor es donde todo se une. Aquí es donde la magia del caching automático sucede.
La verificación de método GET al inicio es guardián de seguridad. Solo las operaciones de lectura se cachean. Es la primera regla del cache club: no cachear operaciones que modifican estado.
El header x-skip-cache es override manual. A veces necesitan forzar datos frescos del servidor, ignorar el cache. Es como el botón de refresh forzado en el navegador: útil cuando saben que los datos cambiaron.
El patrón de verificar cache primero es eficiencia. ¿Para qué hacer una petición si ya tienen la respuesta? Es como verificar si tienen algo en casa antes de ir a comprarlo.
Los console.log de cache hit/miss no son solo debugging; son métricas. Pueden ver qué tan efectivo es su cache. Si tienen 90% cache hits, están ahorrando 90% de peticiones. Son números que importan.
El operador of para retornar cache es creación de Observable desde un valor. El cache es síncrono, pero la interfaz espera un Observable. of lo envuelve apropiadamente. Es adaptación de tipos.
El pipe con tap para guardar en cache es elegancia. El flujo de datos no se interrumpe; tap observa y guarda una copia en cache. El componente recibe los datos normalmente. Es interceptación no invasiva.
La función withCache como operador personalizado es reutilización avanzada. Pueden aplicar caching a cualquier Observable, no solo HTTP. Es abstracción del patrón de caching.
El patrón de emitir cache inmediatamente y luego hacer request real es optimización de UX. El usuario ve datos inmediatamente (aunque sean viejos), luego se actualizan con datos frescos. Es percepción de velocidad.
shareReplay(1) al final es optimización importante. Si múltiples componentes se suscriben al mismo Observable, solo se hace una petición. Es multicasting eficiente.
________________________________________
Diapositiva 20: Optimización de Requests (3 minutos)
Estas técnicas de optimización son las que separan aplicaciones amateur de profesionales.
debounceTime para búsquedas es respeto por el servidor. No necesitan buscar cada vez que el usuario presiona una tecla. Esperan que termine de escribir. 300ms es el sweet spot: suficientemente rápido para sentirse responsivo, suficientemente lento para evitar peticiones innecesarias.
distinctUntilChanged es inteligencia adicional. Si el usuario escribe "Angular", borra la "r" y la vuelve a escribir, el valor no cambió. No necesitan buscar de nuevo. Es eliminación de redundancia.
switchMap es cancelación automática. Si el usuario escribe rápido, no necesitan los resultados de búsquedas intermedias. Solo la última importa. Es como cuando cambian de canal rápidamente: no necesitan cargar todos los canales intermedios.
El check de longitud mínima es validación temprana. No busquen con una sola letra; los resultados serán demasiado amplios para ser útiles. Es filtrado en la fuente.
shareReplay para compartir resultados es eficiencia. Si múltiples partes de la UI necesitan los mismos resultados de búsqueda, no hagan múltiples peticiones. Es cache a nivel de Observable.
Batch requests con forkJoin es paralelización. En lugar de hacer peticiones secuenciales, las hacen en paralelo. Es como cocinar varios platos al mismo tiempo en lugar de uno por uno.
El catchError que retorna null en lugar de fallar todo el batch es resiliencia. Una petición fallida no debería arruinar todas las demás. Es aislamiento de fallos.
El filtrado de nulls al final asegura que solo retornan resultados válidos. Es limpieza de datos post-procesamiento.
________________________________________
Diapositiva 21: Upload y Download de Archivos (4 minutos)
El manejo de archivos es un requisito común que tiene sus propias complejidades.
FormData para uploads es el contenedor correcto. No pueden enviar archivos como JSON. FormData maneja archivos binarios, múltiples archivos, metadata. Es el formato que los servidores esperan para uploads.
HttpRequest con reportProgress es transparencia en acción. Los usuarios no quieren ver una barra de progreso genérica; quieren ver progreso real. 23%... 47%... 89%... Es feedback granular que genera confianza.
El tipo HttpEvent es una unión de diferentes tipos de eventos. UploadProgress mientras sube, Response cuando termina. Necesitan verificar el tipo antes de usar. Es type safety en eventos asíncronos.
El cálculo de porcentaje con verificación de total es programación defensiva. A veces event.total puede ser undefined (el servidor no reportó el tamaño). División por undefined da NaN. La verificación previene mostrar "NaN%" al usuario.
El signal uploadProgress para estado reactivo es binding moderno. Actualizan el signal, la UI se actualiza automáticamente. No necesitan manipular el DOM manualmente. Es reactividad aplicada.
La verificación de event.type es manejo correcto de eventos. No todos los eventos tienen la misma estructura. UploadProgress tiene loaded y total, Response tiene body. Es acceso seguro a propiedades.
El manejo del input file con optional chaining (?.) es JavaScript moderno. Si no hay archivo seleccionado, no hacen nada. Sin errores, sin crashes. Es programación defensiva elegante.
El patrón completo muestra upload profesional: selección de archivo, barra de progreso real, manejo de respuesta, gestión de errores. Es la experiencia que los usuarios esperan en 2025.
________________________________________
Diapositiva 22: Websockets y SSE (4 minutos)
La comunicación en tiempo real es cada vez más importante en aplicaciones modernas.
Server-Sent Events (SSE) es comunicación unidireccional del servidor al cliente. Perfecto para notificaciones, actualizaciones de estado, feeds en vivo. Es como suscribirse a un canal de noticias: reciben actualizaciones cuando hay algo nuevo.
EventSource es la API del navegador para SSE. Es más simple que WebSockets para casos unidireccionales. No necesitan librería adicional, está built-in. Es simplicidad cuando no necesitan complejidad.
El Observable wrapper hace SSE compatible con el ecosistema Angular. Pueden usar operadores RxJS, combinar con otros streams, todo el poder de la programación reactiva. Es integración elegante.
El retry con delay para reconexión es resiliencia. Las conexiones de larga duración pueden caerse. El retry automático con delay evita bombardear el servidor. Es recuperación graceful de fallos de conexión.
WebSocket para comunicación bidireccional es el siguiente nivel. No solo reciben; también envían. Chat en tiempo real, colaboración en vivo, juegos multijugador. Es comunicación full-duplex.
La librería RxJS webSocket simplifica WebSockets enormemente. Manejo automático de reconexión, serialización/deserialización, interfaz Observable. Es WebSocket sin el dolor de cabeza.
Los observers para open y close dan visibilidad del estado de conexión. Pueden mostrar un indicador "conectado/desconectado", pueden intentar reconectar, pueden cachear mensajes para enviar cuando se reconecte. Es gestión inteligente de conexión.
El método send abstrae la complejidad. Envían objetos JavaScript, la librería los serializa a JSON. Simple para el desarrollador, correcto en el wire. Es abstracción útil.
________________________________________
Diapositiva 23: Testing HTTP (5 minutos)
Testing de servicios HTTP no es opcional; es su seguro contra regresiones.
HttpClientTestingModule es su simulador de vuelo. Pueden probar todos los escenarios sin hacer peticiones reales. Es rápido, determinístico, no depende de servicios externos. Es testing confiable.
HttpTestingController es su panel de control para tests. Pueden verificar qué peticiones se hicieron, en qué orden, con qué parámetros. Pueden simular respuestas exitosas, errores, timeouts. Es control total del entorno HTTP.
expectOne verifica que se hizo exactamente una petición a esa URL. Si se hicieron cero o dos, el test falla. Es assertion precisa sobre comportamiento HTTP.
flush simula la respuesta del servidor. Pueden enviar datos exitosos, errores, lo que necesiten para el test. Es simulación controlada de respuestas.
El afterEach con verify es limpieza importante. Verifica que no quedaron peticiones pendientes sin responder. Peticiones colgadas pueden causar comportamiento extraño en tests subsiguientes. Es higiene de tests.
El test de manejo de errores es tan importante como el caso exitoso. ¿Qué pasa cuando el servidor retorna 500? ¿404? ¿Timeout? Necesitan verificar que su aplicación maneja estos casos gracefully.
La expectativa de fallar con next: () => fail() es patrón de testing para errores. Si el Observable emite un valor cuando esperaban un error, el test debe fallar. Es verificación de que el error se propaga correctamente.
El flush con status y statusText simula errores HTTP específicos. Pueden probar cada código de error que su aplicación necesita manejar. Es cobertura completa de casos de error.
________________________________________
Diapositiva 24: Recursos y Referencias (3 minutos)
Aquí tienen todo lo necesario para profundizar y practicar lo aprendido hoy.
La documentación oficial de HttpClient es su biblia. No es solo referencia; es guía de mejores prácticas, ejemplos del mundo real, casos de uso avanzados. Cada vez que la leo, aprendo algo nuevo.
RxJS Operators documentation es su enciclopedia de transformaciones. Hay un operador para casi cualquier problema que puedan imaginar. El truco es saber que existe. Dediquen tiempo a explorar.
El repositorio del curso tiene todo funcionando. No es pseudocódigo; es código real, probado, documentado. Cada laboratorio está en su propia rama. Pueden ver la evolución, comparar soluciones.
JSON Server es su mejor amigo para desarrollo. No necesitan un backend real para empezar. Pueden simular cualquier API REST en minutos. Es prototipado rápido sin dependencias.
El archivo db.json es su base de datos de desarrollo. Es JSON simple, pueden editarlo manualmente, agregar datos de prueba, simular diferentes escenarios. Es flexibilidad total para testing.
Los scripts npm están configurados para su conveniencia. npm run lab1 inicia el primer laboratorio con hot reload. No necesitan recordar comandos complejos. Es automatización de tareas comunes.
El comando de testing con coverage les muestra qué tan bien están probando su código. Apunten a 80% o más. No es sobre el número; es sobre confianza en su código.
Los enlaces directos a secciones específicas de documentación ahorran tiempo. No necesitan buscar; van directo al punto. Es eficiencia en aprendizaje.
________________________________________
Diapositiva 25: Cierre y Q&A (5 minutos)
Felicitaciones. Han completado una de las sesiones más técnicas y prácticas del curso.
Hoy dominaron HttpClient completamente. Ya no están limitados a aplicaciones offline. Pueden comunicarse con cualquier API REST del mundo. Es como haberles dado pasaporte y visa para el mundo digital.
El error handling profesional que implementaron es su red de seguridad. Los usuarios verán mensajes útiles, las peticiones se reintentan inteligentemente, los problemas se registran para análisis. Es la diferencia entre una aplicación que frustra y una que deleita.
Los interceptors que crearon son automatización pura. Autenticación automática, logging transparente, transformación invisible. Es trabajo que no tienen que repetir en cada servicio. Es el principio DRY llevado al extremo.
El caching y optimización elevan su aplicación al siguiente nivel. De lenta y pesada a rápida y eficiente. Los usuarios no notan el caching cuando funciona bien; ese es el punto. Es optimización invisible.
RxJS y los operadores que aplicaron son programación reactiva en acción. No es solo sobre HTTP; es un paradigma que pueden aplicar en toda su aplicación. Es pensar en flujos de datos, no en valores estáticos.
El testing que aprendieron asegura que todo sigue funcionando mientras evoluciona su código. Es confianza para refactorizar, para agregar features, para dormir tranquilos sabiendo que su código es sólido.
La próxima sesión, el martes 19 de agosto, profundizaremos en Asincronía y RxJS. Si hoy fueron usuarios de RxJS, el martes serán maestros. Operadores avanzados, patrones complejos, y la comparación con Signals.
Mi email está disponible para consultas. No duden en escribir si se encuentran con problemas implementando estas técnicas. A veces un pequeño empujón es todo lo que necesitan para desbloquearse.
Han dado un salto cuántico hoy. De aplicaciones aisladas a sistemas conectados. De manejo básico de errores a resiliencia profesional. De peticiones simples a comunicación optimizada.
Gracias por su energía y dedicación durante estas tres horas intensas. Lo que aprendieron hoy lo usarán en cada proyecto Angular que construyan.
¡Excelente trabajo! Nos vemos el martes 19 de agosto a las 19:00 para continuar este viaje extraordinario con RxJS avanzado.
¡Hasta la próxima sesión! 🚀

