GUI√ìN DETALLADO - SESI√ìN 7: ASINCRON√çA Y RXJS
PROVIAS DESCENTRALIZADO
________________________________________
Diapositiva 1: Car√°tula (2 minutos)
Muy buenas noches a todos. Bienvenidos a la sesi√≥n 7 de nuestro curso Angular 18, una sesi√≥n que marca un antes y un despu√©s en su comprensi√≥n del desarrollo web moderno.
Mi nombre es Jhonny Alexander Ramirez Chiroque y hoy martes 19 de agosto de 2025, vamos a desentra√±ar los misterios de la programaci√≥n reactiva. Si en sesiones anteriores aprendieron a construir aplicaciones, hoy aprender√°n a hacerlas pensar y reaccionar inteligentemente.
Imaginen por un momento que est√°n manejando el tr√°fico en una intersecci√≥n importante de Lima. Tienen sem√°foros que deben coordinar, peatones que cruzan, veh√≠culos que giran, ambulancias que necesitan paso prioritario. No pueden detener todo para procesar cada evento; necesitan que todo fluya continuamente, reaccionando a m√∫ltiples situaciones simult√°neamente. Eso es exactamente lo que haremos hoy con c√≥digo: crear sistemas que reaccionen inteligentemente a m√∫ltiples flujos de datos.
Esta sesi√≥n ser√° completamente pr√°ctica. No vamos a teorizar sobre programaci√≥n reactiva; vamos a escribir c√≥digo real que respira, que piensa, que reacciona. Van a sentir el poder de controlar flujos de datos como un director de orquesta controla a sus m√∫sicos.
Angular 18 nos trae dos paradigmas poderosos: RxJS, el veterano confiable de la programaci√≥n reactiva, y Signals, el nuevo prodigio que promete simplificar el manejo de estado. Hoy dominar√°n ambos y, m√°s importante a√∫n, sabr√°n cu√°ndo usar cada uno.
Preparen sus editores, abran sus terminales, y prep√°rense para tres horas de c√≥digo intensivo que cambiar√°n fundamentalmente c√≥mo piensan sobre el flujo de datos en sus aplicaciones.
________________________________________
Diapositiva 2: Objetivos de la Sesi√≥n (2 minutos)
Los objetivos de hoy no son solo t√©cnicos; son transformacionales para su forma de pensar en programaci√≥n.
Dominar la diferencia entre programaci√≥n s√≠ncrona y as√≠ncrona es como entender la diferencia entre una fila de banco tradicional y hacer m√∫ltiples transacciones en cajeros autom√°ticos simult√°neamente. En el mundo s√≠ncrono, todo espera su turno. En el as√≠ncrono, m√∫ltiples operaciones ocurren en paralelo, maximizando eficiencia.
Implementar Promises correctamente es fundamental en el JavaScript moderno. Son como contratos comerciales: "Te prometo entregar este resultado, y si algo sale mal, te explicar√© qu√© pas√≥". Es la base de la confianza en operaciones as√≠ncronas.
El patr√≥n Observer que aprender√°n es como tener un sistema de notificaciones inteligente. Imaginen que son el gerente de proyectos en PROVIAS y necesitan estar al tanto de m√∫ltiples obras simult√°neamente. En lugar de llamar constantemente preguntando el estado, cada obra les notifica autom√°ticamente cuando hay cambios importantes.
Los operadores RxJS son sus herramientas especializadas. Como un chef profesional no solo tiene cuchillos, sino cuchillos espec√≠ficos para cada tarea, ustedes tendr√°n operadores para filtrar, transformar, combinar y manipular flujos de datos con precisi√≥n quir√∫rgica.
Angular Signals representa la evoluci√≥n. Si RxJS es como manejar un auto manual con control total, Signals es como un autom√°tico moderno: m√°s simple para casos comunes, pero igualmente poderoso. Aprender√°n cu√°ndo la simplicidad es ventaja y cu√°ndo necesitan el control granular.
La migraci√≥n de Observables a Signals no es solo un ejercicio acad√©mico. Muchas aplicaciones Angular existentes est√°n haciendo esta transici√≥n. Ser√°n los expertos que sus empresas necesitan para modernizar c√≥digo legacy.
El estado global con Signals resolver√° uno de los problemas m√°s complejos en aplicaciones modernas: compartir estado entre componentes de manera eficiente y predecible. Es como tener un sistema nervioso central para su aplicaci√≥n.
________________________________________
Diapositiva 3: Agenda (1 minuto)
Nuestra agenda est√° dise√±ada como una sinfon√≠a en cuatro movimientos, cada uno construyendo sobre el anterior.
El primer laboratorio de 45 minutos es nuestros cimientos. Exploraremos la asincron√≠a desde sus ra√≠ces: callbacks, promises, async/await. Es como aprender los diferentes sistemas de transporte antes de elegir el m√°s eficiente para cada viaje.
El segundo laboratorio, tambi√©n de 45 minutos, es donde RxJS brilla. Implementaremos el poder de los Observables, esos flujos de datos que son como r√≠os de informaci√≥n que pueden dividirse, unirse, filtrarse y transformarse.
Nuestro break de 15 minutos ser√° crucial. El cerebro necesita tiempo para consolidar estos conceptos abstractos. Es como dejar reposar un buen pisco para que todos los sabores se integren.
El tercer laboratorio de 45 minutos introducir√° Signals, la nueva joya de Angular. Ver√°n c√≥mo simplifica casos que con RxJS requer√≠an ceremonias complejas. Es evoluci√≥n, no revoluci√≥n.
El laboratorio final de 25 minutos es integraci√≥n pura. Migraremos c√≥digo real de RxJS a Signals, crearemos estado global, y ver√°n c√≥mo ambos paradigmas pueden coexistir armoniosamente.
Cada minuto est√° optimizado para m√°ximo aprendizaje pr√°ctico. No hay relleno, solo c√≥digo que importa.
________________________________________
Diapositiva 4: LAB 1 - Introducci√≥n Asincron√≠a (3 minutos)
Bienvenidos al primer laboratorio. Vamos a desmitificar la asincron√≠a de una vez por todas.
La diferencia entre c√≥digo s√≠ncrono y as√≠ncrono es fundamental. El c√≥digo s√≠ncrono es como hacer cola en el banco: cada cliente debe ser atendido completamente antes de pasar al siguiente. Si alguien tarda 30 minutos, todos esperan. Es predecible pero ineficiente.
El c√≥digo as√≠ncrono es como un restaurante bien organizado. El mesero toma su orden y no se queda parado esperando que el chef cocine. Atiende otras mesas, y cuando su plato est√° listo, se lo trae. M√∫ltiples operaciones en paralelo, m√°xima eficiencia.
Miren el ejemplo de fetchDataSync. Esta funci√≥n bloquear√≠a completamente su aplicaci√≥n por 3 segundos. En el mundo web, 3 segundos es una eternidad. Los usuarios pensar√≠an que la aplicaci√≥n se colg√≥. Es como si un cajero del banco se fuera a almorzar mientras lo atiende.
fetchDataAsync, en cambio, es cortes√≠a y eficiencia. La funci√≥n dice "voy a buscar esos datos, mientras tanto, sigue con tu vida". El await es simplemente un punto de encuentro: "cuando tengas los datos, continuamos desde aqu√≠".
El Event Loop de JavaScript es el director de orquesta invisible. Call Stack es donde se ejecuta el c√≥digo. Web APIs maneja operaciones as√≠ncronas. Callback Queue espera su turno. Event Loop coordina todo. Es como el sistema de control de tr√°fico a√©reo: m√∫ltiples aviones (operaciones) en el aire, pero todos aterrizan ordenadamente.
Este concepto es la base de todo lo que viene. Sin entender asincron√≠a, RxJS y Signals ser√≠an magia negra incomprensible. Con este entendimiento, son herramientas l√≥gicas y poderosas.
________________________________________
Diapositiva 5: LAB 1 - Callbacks vs Promises (4 minutos)
Ahora vamos a ver la evoluci√≥n hist√≥rica de c√≥mo JavaScript ha manejado la asincron√≠a.
El Callback Hell que ven arriba es una pesadilla real que muchos desarrolladores vivieron. Es como esas instrucciones de muebles donde cada paso depende del anterior, pero escritas en un solo p√°rrafo interminable. Cada callback anidado a√±ade un nivel de indentaci√≥n, y pronto su c√≥digo parece una pir√°mide tumbada.
Imaginen que necesitan hacer un tr√°mite en PROVIAS que requiere: primero obtener un documento del archivo, luego llevarlo a legal para revisi√≥n, despu√©s a contabilidad para aprobaci√≥n, y finalmente a la gerencia para firma. Con callbacks, ser√≠a como tener que explicar todo el proceso completo cada vez, en lugar de tener un flujo claro.
Las Promises llegaron como salvaci√≥n. Transformaron la pir√°mide en una cadena elegante. Cada "then" es como un paso en un proceso bien documentado. Si algo falla en cualquier punto, el "catch" al final lo maneja. Es como tener un supervisor que sabe exactamente qu√© hacer cuando algo sale mal, sin importar en qu√© paso ocurra.
Pero async/await es la cereza del pastel. Hace que el c√≥digo as√≠ncrono se lea como s√≠ncrono. Es enga√±osamente simple. Cada await es como decir "espera aqu√≠ hasta que esto est√© listo, pero no bloquees nada m√°s". El try/catch envuelve todo en un manejo de errores familiar y limpio.
La funci√≥n getShippingInfo es poes√≠a en c√≥digo. Lee como una receta de cocina: primero obten el usuario, luego sus √≥rdenes, despu√©s los detalles, finalmente la informaci√≥n de env√≠o. Si algo falla, el catch lo atrapa. Limpio, legible, mantenible.
Esta evoluci√≥n no es solo sintaxis m√°s bonita. Cada paradigma resuelve problemas reales del anterior. Callbacks son el fundamento, Promises a√±aden composabilidad, Async/Await a√±ade legibilidad. Necesitan entender los tres porque encontrar√°n los tres en c√≥digo real.
________________________________________
Diapositiva 6: LAB 1 - Implementaci√≥n con Promises (5 minutos)
Vamos a implementar un servicio real con Promises, aplicando patrones profesionales.
El UserPromiseService que estamos creando es un ejemplo del mundo real. No es c√≥digo de juguete; es lo que escribir√≠an en producci√≥n. Noten c√≥mo cada m√©todo tiene un prop√≥sito espec√≠fico y maneja casos particulares.
El m√©todo getUser es la operaci√≥n b√°sica. Usa fetch, la API moderna del navegador. El chequeo de response.ok es crucial: fetch no lanza error para respuestas HTTP fallidas como 404 o 500. Tienen que verificar expl√≠citamente. Es como verificar que un paquete lleg√≥ en buenas condiciones antes de firmarlo.
getMultipleUsers muestra el poder de Promise.all. Imaginen que necesitan informaci√≥n de 5 proveedores diferentes para un proyecto. En lugar de llamar uno por uno secuencialmente (que tomar√≠a 5 veces m√°s), llaman a todos en paralelo. Promise.all espera a que todos respondan. Si uno falla, todo falla. Es el principio de "todo o nada", √∫til cuando necesitan datos completos.
getUserWithTimeout resuelve un problema real: servicios lentos. Es como poner un l√≠mite de tiempo en una reuni√≥n. Si no han terminado en 5 segundos, asumimos que algo anda mal y seguimos adelante. Promise.race es una carrera: el primero que responde gana, sea el resultado real o el timeout.
getUsersSafe con Promise.allSettled es resiliencia pura. A diferencia de Promise.all, no falla si una promesa falla. Es como enviar invitaciones a una reuni√≥n: si algunos no pueden venir, la reuni√≥n contin√∫a con los que s√≠ pueden. Cada resultado indica si fue exitoso o fall√≥, permitiendo manejo granular.
Estos patrones no son te√≥ricos. Los usar√°n constantemente. M√∫ltiples llamadas a APIs, timeouts para servicios externos, manejo robusto cuando algunos datos son opcionales. Es su caja de herramientas para asincron√≠a con Promises.
________________________________________
Diapositiva 7: LAB 1 - Async/Await Patterns (5 minutos)
Ahora implementaremos patrones avanzados que distinguen a desarrolladores senior de junior.
fetchWithRetry es resiliencia inteligente. En el mundo real, las redes fallan, los servidores tienen hipos. Este patr√≥n reintenta autom√°ticamente con backoff exponencial: espera 1 segundo, luego 2, luego 4. Es como tocar una puerta: primero suave, si no responden, un poco m√°s fuerte, pero no indefinidamente.
El patr√≥n es recursivo, elegante. Si funciona, retorna el resultado. Si falla y quedan reintentos, espera y lo intenta de nuevo. Si se acabaron los reintentos, propaga el error. El delay exponencial previene bombardear un servidor ya sobrecargado.
processSequentially es para cuando el orden importa. Imaginen que est√°n procesando transferencias bancarias: cada una debe completarse antes de procesar la siguiente para mantener el balance correcto. El for...of con await asegura procesamiento ordenado. No es el m√°s r√°pido, pero es el m√°s seguro cuando el orden es cr√≠tico.
processBatch es optimizaci√≥n inteligente. Tienen 100 operaciones pero no quieren abrumar el servidor con 100 peticiones simult√°neas. Procesan en lotes de 5: suficiente paralelismo para ser eficiente, suficiente control para no sobrecargar. Es como tener m√∫ltiples cajeros en un banco, pero no infinitos.
El m√©todo sleep es utilidad pura. JavaScript no tiene un sleep nativo, as√≠ que lo creamos. √ötil para debugging, para simular delays, para dar tiempo entre operaciones. Simple pero indispensable.
Estos patrones separan el c√≥digo amateur del profesional. No es solo hacer que funcione; es hacer que funcione confiablemente, eficientemente, y que se recupere graciosamente de fallos. Son patrones que sus aplicaciones necesitar√°n en producci√≥n.
________________________________________
Diapositiva 8: LAB 2 - Introducci√≥n a RxJS (3 minutos)
Bienvenidos al mundo de RxJS, donde los datos fluyen como r√≠os que podemos controlar con precisi√≥n.
La tabla de comparaci√≥n no es solo acad√©mica; cada diferencia tiene implicaciones profundas. Los Observables pueden emitir m√∫ltiples valores en el tiempo, como un sensor de temperatura que reporta cada segundo. Las Promises son un √∫nico evento, como el resultado de un examen.
La caracter√≠stica "Cancelable" es cr√≠tica. Imaginen que est√°n buscando en Google y escriben "restaurantes". Mientras escriben, cada letra genera una b√∫squeda. Con Promises, todas se ejecutar√≠an. Con Observables, cada nueva letra cancela la b√∫squeda anterior. Eficiencia pura.
"Lazy" significa que los Observables no hacen nada hasta que alguien se suscribe. Es como Netflix: las pel√≠culas no se transmiten hasta que alguien presiona play. Las Promises empiezan inmediatamente, como la televisi√≥n tradicional que transmite aunque nadie est√© viendo.
Los m√°s de 100 operadores son su superpoder. Es como tener una cocina profesional completa versus solo una estufa. Pueden filtrar, transformar, combinar, throttle, debounce, retry, cache... las posibilidades son infinitas.
Los ejemplos de creaci√≥n muestran la versatilidad. Observable simple para control total. "of" para valores conocidos. "from" para convertir arrays. "interval" para eventos temporales. "fromEvent" para eventos del DOM. Cada uno resuelve un caso de uso espec√≠fico.
Este es el fundamento de la programaci√≥n reactiva en Angular. HTTP requests retornan Observables. Los eventos del router son Observables. Los formularios emiten Observables. Entender esto es entender Angular moderno.
________________________________________
Diapositiva 9: LAB 2 - Patr√≥n Observer (5 minutos)
El patr√≥n Observer es el coraz√≥n conceptual de RxJS. Vamos a dominarlo completamente.
Un Subject es fascinante porque es Observable y Observer simult√°neamente. Es como ser locutor y oyente de radio al mismo tiempo. Pueden emitir valores (next) y otros pueden suscribirse para recibirlos. √ötil para comunicaci√≥n entre componentes, eventos personalizados, broadcasting de informaci√≥n.
BehaviorSubject es un Subject con memoria. Siempre mantiene el √∫ltimo valor emitido. Cuando alguien nuevo se suscribe, inmediatamente recibe el valor actual. Es perfecto para estado de aplicaci√≥n: el usuario actual, tema seleccionado, configuraci√≥n activa. Como un tablero de anuncios que siempre muestra el √∫ltimo mensaje importante.
ReplaySubject es memoria con esteroides. Puede recordar m√∫ltiples valores pasados. En el ejemplo, recuerda los √∫ltimos 3 mensajes. √ötil para logs, historial de acciones, chat donde los nuevos usuarios necesitan ver mensajes recientes. Es como una grabadora que siempre mantiene los √∫ltimos minutos de conversaci√≥n.
AsyncSubject es el m√°s peculiar. Solo emite el √∫ltimo valor, y solo cuando se completa. Es como esperar a que termine una carrera para anunciar al ganador. √ötil para operaciones que acumulan un resultado final, como c√°lculos complejos o agregaciones.
Los m√©todos updateData, setUser, addMessage muestran c√≥mo emitir valores. Es broadcasting: todos los suscriptores reciben la actualizaci√≥n autom√°ticamente. No necesitan rastrear qui√©n est√° escuchando; solo emiten y RxJS se encarga de la distribuci√≥n.
El patr√≥n de suscripci√≥n con next, error, complete es completo. No es solo recibir valores; es manejar el ciclo de vida completo del stream. Como suscribirse a un servicio: recibes contenido, manejas problemas si ocurren, y sabes cu√°ndo el servicio termina.
________________________________________
Diapositiva 10: LAB 2 - Operadores de Transformaci√≥n (5 minutos)
Los operadores de transformaci√≥n son donde RxJS muestra su verdadero poder. Son sus pinceles para pintar con datos.
El operador map es transformaci√≥n pura. getUppercaseNames toma usuarios y retorna nombres en may√∫sculas. Es como tener una l√≠nea de ensamblaje donde cada elemento pasa por una transformaci√≥n espec√≠fica. Simple, predecible, potente.
filter es su guardi√°n de calidad. getActiveUsers solo deja pasar usuarios activos. Es como un portero en un club exclusivo: solo entran los que cumplen los criterios. √ötil para limpiar datos, mostrar subconjuntos, implementar b√∫squedas.
tap es para efectos secundarios sin modificar el stream. Es como tener c√°maras de seguridad en su l√≠nea de producci√≥n: observan todo pero no interfieren. Perfectamente √∫til para logging, caching, analytics. getUsersWithLogging registra y cachea sin afectar los datos que fluyen.
switchMap es magia para b√∫squedas. Cada vez que el usuario escribe, cancela la b√∫squeda anterior y comienza una nueva. Imaginen un asistente que, cuando le cambian las instrucciones, inmediatamente olvida la tarea anterior y se enfoca en la nueva. Con debounceTime esperan 300ms despu√©s de que el usuario deja de escribir. distinctUntilChanged evita buscar si el t√©rmino no cambi√≥. Es optimizaci√≥n en m√∫ltiples niveles.
mergeMap es paralelismo controlado. getUserDetails toma una lista de IDs y obtiene detalles de cada uno en paralelo. Es como tener m√∫ltiples empleados trabajando simult√°neamente en diferentes tareas. Todos los resultados se combinan en un stream final.
Estos operadores son composables. Pueden encadenar map, filter, tap, switchMap en cualquier combinaci√≥n. Es como tener bloques de LEGO que siempre encajan perfectamente. La composabilidad es lo que hace a RxJS tan poderoso para casos complejos.
________________________________________
Diapositiva 11: LAB 2 - Operadores de Combinaci√≥n (5 minutos)
Los operadores de combinaci√≥n son sus herramientas para orquestar m√∫ltiples flujos de datos.
combineLatest es sincronizaci√≥n continua. Cada vez que cualquier Observable emite, combina los √∫ltimos valores de todos. Es como un dashboard en tiempo real: cuando cualquier m√©trica se actualiza, el dashboard se recalcula. Perfecto para formularios donde m√∫ltiples campos afectan un resultado, o vistas que dependen de m√∫ltiples fuentes de datos.
forkJoin es el "todo listo" definitivo. Espera a que todos los Observables completen y emite todos los resultados juntos. Es como esperar a que todos los invitados lleguen antes de empezar la reuni√≥n. Ideal para inicializaci√≥n de aplicaci√≥n donde necesitan m√∫ltiples datos antes de mostrar la interfaz.
merge es el combinador m√°s simple: todos los valores de todos los Observables en un solo stream. No le importa el orden ni la sincronizaci√≥n. Es como tener m√∫ltiples mangueras vertiendo en el mismo tanque. √ötil para combinar m√∫ltiples fuentes de eventos: clicks, teclado, touch.
zip es emparejamiento estricto por √≠ndice. El primer valor del primer Observable se empareja con el primer valor del segundo, y as√≠ sucesivamente. Es como hacer parejas de baile: cada uno con su pareja correspondiente. Si un Observable emite m√°s r√°pido, espera a su pareja. √ötil cuando necesitan sincronizaci√≥n estricta.
concat es secuencialidad garantizada. El segundo Observable no empieza hasta que el primero complete. Es como una lista de reproducci√≥n: cada canci√≥n espera a que termine la anterior. Perfecto para operaciones que deben ocurrir en orden espec√≠fico.
Estos operadores resuelven problemas complejos de coordinaci√≥n elegantemente. Sin ellos, necesitar√≠an flags, contadores, callbacks anidados. Con ellos, declaran la relaci√≥n y RxJS maneja la complejidad.
________________________________________
Diapositiva 12: LAB 2 - Manejo de Errores RxJS (5 minutos)
El manejo de errores en RxJS es sofisticado y poderoso. Vamos a implementar estrategias profesionales.
catchError es su red de seguridad b√°sica. getUsersSafe atrapa cualquier error y retorna un array vac√≠o. Es como tener un plan B: si no pueden obtener los datos, al menos la aplicaci√≥n no explota. El usuario ve una lista vac√≠a en lugar de una pantalla de error. A veces, fallar silenciosamente es mejor que fallar ruidosamente.
retry es persistencia simple. Reintenta 3 veces antes de rendirse. Es como llamar a una puerta: si no responden la primera vez, intentan un par de veces m√°s antes de irse. √ötil para errores transitorios de red. Pero cuidado: reintentar un error 404 es in√∫til; el recurso no existe y no aparecer√° m√°gicamente.
retryWhen con backoff exponencial es inteligencia aplicada. No solo reintenta; espera progresivamente m√°s entre intentos. El scan acumula intentos, el timer crea delays exponenciales. Es como el protocolo diplom√°tico: primer intento cort√©s, segundo m√°s insistente, tercero m√°s espaciado. Evita bombardear servidores ya estresados.
La estrategia robusta robustDataFetch es producci√≥n-ready. Timeout previene esperas infinitas. Retry inteligente que no reintenta 404s. Manejo especial para 401 redirigiendo al login. EMPTY para errores irrecuperables que no deber√≠an propagarse. Es defensa en profundidad: m√∫ltiples capas de protecci√≥n.
El patr√≥n de verificar status antes de decidir si reintentar es crucial. No todos los errores son iguales. 401 es autenticaci√≥n, no tiene sentido reintentar sin reautenticar. 500 es error del servidor, tal vez se recupere. 429 es rate limiting, definitivamente esperar antes de reintentar.
Este manejo robusto de errores es lo que separa aplicaciones hobby de aplicaciones profesionales. Los usuarios no ven "undefined" o pantallas en blanco. Ven mensajes √∫tiles, la aplicaci√≥n se recupera autom√°ticamente cuando es posible, y degrada graciosamente cuando no lo es.
________________________________________
Diapositiva 13: BREAK (15 minutos)
Excelente trabajo hasta aqu√≠. Han absorbido conceptos densos que muchos desarrolladores tardan meses en dominar.
Han conquistado la asincron√≠a, desde callbacks hasta async/await. Ya no son v√≠ctimas del callback hell; son arquitectos de c√≥digo as√≠ncrono elegante. Sus aplicaciones pueden manejar m√∫ltiples operaciones simult√°neas sin sudar.
El patr√≥n Observer ya no es un misterio. Entienden c√≥mo fluyen los datos, c√≥mo se propagan los cambios, c√≥mo m√∫ltiples partes de su aplicaci√≥n pueden reaccionar a eventos sin acoplamiento directo. Es programaci√≥n reactiva en su esencia.
Los operadores RxJS que dominaron son herramientas poderosas. map, filter, switchMap, combineLatest... cada uno resuelve problemas espec√≠ficos elegantemente. Son como haber aprendido un nuevo idioma que les permite expresar operaciones complejas de manera concisa.
El manejo de errores robusto que implementaron asegura que sus aplicaciones sean resilientes. No solo funcionan en el camino feliz; se recuperan de fallos, reintentan inteligentemente, degradan graciosamente. Es profesionalismo en c√≥digo.
Durante este break, lev√°ntense y estiren. La programaci√≥n reactiva es mentalmente intensa. Su cerebro ha estado haciendo gimnasia abstracta. Denle un descanso merecido.
Tomen agua, caf√©, lo que prefieran. La hidrataci√≥n es crucial para mantener la concentraci√≥n. La segunda mitad introducir√° Signals, el nuevo paradigma de Angular que simplifica muchos casos de uso.
Reflexionen sobre c√≥mo RxJS puede resolver problemas en sus proyectos actuales. ¬øD√≥nde tienen c√≥digo complejo manejando asincron√≠a que podr√≠a simplificarse con Observables? ¬øQu√© operadores resolver√≠an elegantemente sus casos de uso?
Lo que viene es emocionante: Signals, la nueva API que est√° revolucionando c√≥mo manejamos estado en Angular. Es m√°s simple que RxJS para muchos casos, pero igualmente poderosa. Van a amar la simplicidad.
Nos vemos en 15 minutos, a las 20:45. Regresen con mente fresca y lista para el futuro del estado reactivo en Angular.
________________________________________
Diapositiva 14: LAB 3 - Introducci√≥n a Signals (3 minutos)
Bienvenidos de vuelta. Signals es la revoluci√≥n silenciosa de Angular, y est√°n a punto de entender por qu√©.
Signals es la respuesta de Angular a una pregunta que la comunidad ha estado haciendo por a√±os: ¬øpuede el manejo de estado ser m√°s simple? RxJS es poderoso pero complejo. Para estado local de componentes, a menudo es excesivo. Signals llena ese vac√≠o perfectamente.
Un signal es, en esencia, un contenedor reactivo de un valor. Cuando el valor cambia, todo lo que depende de √©l se actualiza autom√°ticamente. Es como tener celdas en Excel: cambias una celda, todas las f√≥rmulas que la usan se recalculan instant√°neamente.
La sintaxis es deliciosamente simple. signal(0) crea un signal con valor inicial 0. Para leer, llaman la funci√≥n: count(). Para escribir, usan set: count.set(5). Para actualizar bas√°ndose en el valor actual, usan update: count.update(v => v + 1). No hay suscripciones que manejar, no hay unsubscribe que recordar.
computed es magia derivada. doubled siempre ser√° el doble de count, autom√°ticamente. No necesitan actualizar doubled manualmente cuando count cambia. Es declarativo: describen la relaci√≥n una vez, Angular la mantiene por siempre.
effect es para efectos secundarios. Cada vez que un signal que usa cambia, el effect se re-ejecuta. Es como tener un observador autom√°tico que reacciona a cambios. Perfecto para sincronizar con localStorage, hacer logs, disparar animaciones.
Las ventajas son tangibles. Mejor performance porque no requiere Zone.js para detecci√≥n de cambios. M√°s simple porque no hay Observables que gestionar para estado local. Integraci√≥n perfecta con templates sin async pipe. Type-safe por defecto sin gimnasia de tipos.
________________________________________
Diapositiva 15: LAB 3 - Signals en Componentes (5 minutos)
Vamos a implementar un componente real con Signals y ver√°n cu√°n elegante es el c√≥digo resultante.
El CounterComponent es simplicidad cristalina. No hay Subjects, no hay Observables, no hay suscripciones. Solo signals que contienen valores y se actualizan reactivamente.
El signal count mantiene el contador actual. history mantiene los √∫ltimos valores. Son como variables de instancia, pero reactivas. Cuando cambian, la vista se actualiza autom√°ticamente.
Los computed values doubled e isEven son derivaciones autom√°ticas. No necesitan actualizarlos manualmente; siempre est√°n sincronizados con count. Es como tener f√≥rmulas en una hoja de c√°lculo: siempre actualizadas, siempre correctas.
El effect en el constructor es brillante. Cada vez que count cambia, autom√°ticamente actualiza el historial. No necesitan llamar manualmente "addToHistory" en cada m√©todo que modifica count. La relaci√≥n est√° declarada una vez y se mantiene por siempre.
Los m√©todos increment, decrement, reset son operaciones puras. Modifican el signal, y todo lo dem√°s se actualiza autom√°ticamente. No hay que notificar a nadie, no hay que disparar eventos. Solo actualizar el estado y Angular hace el resto.
En el template, la sintaxis es limpia. {{ count() }} para mostrar el valor. No necesitan async pipe, no necesitan suscripciones. Los signals son funciones, las llaman para obtener el valor actual.
El loop @for con history muestra arrays reactivos. Cuando history cambia, la lista se actualiza autom√°ticamente. El track asegura rendimiento √≥ptimo en re-renderizados.
Este componente har√≠a lo mismo con RxJS requerir√≠a el doble de c√≥digo y ser√≠a m√°s complejo de entender. Signals brilla para estado local de componentes.
________________________________________
Diapositiva 16: LAB 3 - Signals Avanzados (5 minutos)
Ahora vamos a trabajar con estructuras de datos m√°s complejas: objetos y arrays en Signals.
El TodoSignalsService muestra patterns profesionales para manejar estado complejo con Signals. No es solo un contador; es una aplicaci√≥n real con operaciones CRUD completas.
El signal privado todosSignal contiene el array de todos. Es privado porque no queremos que componentes externos lo modifiquen directamente. Solo a trav√©s de m√©todos controlados del servicio.
asReadonly() es encapsulaci√≥n inteligente. Los componentes pueden leer el valor pero no modificarlo. Es como dar acceso de solo lectura a una base de datos. Pueden ver pero no tocar.
Los computed signals son potentes. completedTodos filtra autom√°ticamente todos completados. activeTodos filtra los activos. todoCount cuenta el total. Cuando todosSignal cambia, todos estos se recalculan autom√°ticamente. Es como tener vistas materializadas que siempre est√°n actualizadas.
addTodo muestra modificaci√≥n inmutable. No mutamos el array existente; creamos uno nuevo con el spread operator. Signals detecta el cambio porque es un nuevo array. Es el mismo principio que en Redux pero m√°s simple.
toggleTodo es cirug√≠a precisa. Mapeamos el array, creando un nuevo todo solo para el que cambia. Los dem√°s se mantienen igual (misma referencia). Es eficiencia: Angular solo re-renderiza lo que cambi√≥.
removeTodo filtra el todo no deseado. clearCompleted elimina todos los completados. Cada operaci√≥n es inmutable, predecible, testeable.
Este patr√≥n escala perfectamente. Pueden manejar estado tan complejo como necesiten. La reactividad es autom√°tica, el c√≥digo es limpio, el rendimiento es √≥ptimo.
________________________________________
Diapositiva 17: LAB 3 - Effects y Side Effects (5 minutos)
Los effects son el puente entre el mundo reactivo de Signals y el mundo imperativo de side effects.
El EffectsComponent muestra casos de uso reales para effects. No son solo console.log; son operaciones significativas que necesitan ocurrir cuando el estado cambia.
El searchEffect es auto-b√∫squeda inteligente. Cuando searchTerm cambia, autom√°ticamente busca si el t√©rmino tiene m√°s de 3 caracteres. No necesitan bot√≥n de b√∫squeda, no necesitan manejar eventos. El effect observa y reacciona.
untracked es crucial aqu√≠. Dentro del effect, modificamos isLoading y llamamos performSearch. Sin untracked, esto crear√≠a una dependencia circular: el effect depender√≠a de isLoading, que el mismo effect modifica. untracked dice "haz esto pero no lo rastrees como dependencia".
persistenceEffect guarda autom√°ticamente en localStorage. Cada vez que searchResults cambia, se persiste. Es backup autom√°tico, historial autom√°tico. Los usuarios pueden recargar la p√°gina y mantener sus resultados.
animationEffect con cleanup es sofisticaci√≥n. Cuando hay resultados, a√±ade una clase CSS para animar. onCleanup asegura que la clase se remueva cuando el effect se re-ejecuta o el componente se destruye. Es gesti√≥n de recursos responsable.
performSearch muestra integraci√≥n con el mundo Observable. Signals no reemplaza completamente RxJS; coexisten. HTTP sigue retornando Observables. El patr√≥n es hacer la petici√≥n HTTP, y en el subscribe, actualizar el signal. Es el puente entre ambos mundos.
La clave es entender cu√°ndo usar effects. Son para sincronizaci√≥n con sistemas externos: localStorage, console, DOM, analytics. No son para derivar valores (usen computed) ni para l√≥gica de negocio (usen m√©todos).
________________________________________
Diapositiva 18: LAB 3 - Signals vs Observables (5 minutos)
Esta comparaci√≥n es crucial. No es sobre cu√°l es mejor, sino sobre cu√°ndo usar cada uno.
Signals es perfecto para estado local del componente. Es s√≠ncrono, simple, no requiere gesti√≥n de suscripciones. Si su estado vive y muere con el componente, Signals es probablemente la mejor opci√≥n.
Observables brillan para eventos as√≠ncronos. HTTP requests, WebSockets, eventos del DOM que necesitan transformaci√≥n compleja. Cuando necesitan los operadores de RxJS, cuando manejan streams de datos, Observables es insustituible.
La combinaci√≥n es poderosa. loadUserToSignal muestra el patr√≥n: hacer petici√≥n HTTP con Observable, actualizar Signal con el resultado. Es lo mejor de ambos mundos: la potencia de RxJS para la operaci√≥n as√≠ncrona, la simplicidad de Signals para el estado.
toObservable y toSignal son los puentes bidireccionales. Pueden convertir un Signal a Observable cuando necesitan operadores RxJS. Pueden convertir un Observable a Signal cuando quieren simplicidad en el template.
El ejemplo de interoperabilidad muestra que no es una decisi√≥n binaria. En la misma aplicaci√≥n, el mismo componente, pueden usar ambos. Signals para estado local, Observables para operaciones as√≠ncronas complejas.
La regla de oro: si pueden resolverlo con Signals, √∫senlo. Es m√°s simple. Si necesitan operadores RxJS, timing complejo, o manejan streams de eventos, usen Observables. No es competencia; es complementariedad.
Este servicio muestra madurez arquitect√≥nica. No es fanatismo por una tecnolog√≠a; es usar la herramienta correcta para cada trabajo.
________________________________________
Diapositiva 19: LAB 4 - Estado Global con Signals (5 minutos)
El estado global es uno de los problemas m√°s complejos en aplicaciones modernas. Signals lo hace elegante.
GlobalStateService es su store centralizado, pero sin la ceremonia de NgRx o Akita. Es estado global con la simplicidad de Signals.
Los signals privados con underscore son encapsulaci√≥n. _user, _theme, _language, _notifications son modificables solo dentro del servicio. Es control de acceso, previene modificaciones accidentales.
La exposici√≥n como readonly es API p√∫blica limpia. Los componentes pueden leer pero no escribir directamente. Deben usar los m√©todos del servicio para modificaciones. Es el mismo principio que en bases de datos: SELECT para todos, UPDATE solo con permisos.
Los computed globales son inteligencia derivada. isAuthenticated siempre refleja si hay usuario. unreadCount cuenta notificaciones no le√≠das. isDarkMode indica el tema actual. Son valores derivados que siempre est√°n sincronizados, sin l√≥gica duplicada.
Los m√©todos de acci√≥n son la √∫nica forma de modificar estado. login no solo setea el usuario; tambi√©n carga preferencias. logout limpia todo. toggleTheme alterna y persiste. Es encapsulaci√≥n de l√≥gica de negocio.
La persistencia en localStorage es transparente. Los componentes no saben ni les importa c√≥mo se persiste. Solo usan el servicio. Si ma√±ana cambian a IndexedDB o a un backend, los componentes no cambian.
Este patr√≥n escala perfectamente. Pueden tener m√∫ltiples servicios de estado para diferentes dominios. UserState, CartState, UIState. Cada uno manejando su pedazo del estado global.
La inyecci√≥n con providedIn: 'root' asegura singleton. Todos los componentes comparten la misma instancia, el mismo estado. Es estado verdaderamente global.
________________________________________
Diapositiva 20: LAB 4 - Migraci√≥n de RxJS a Signals (5 minutos)
La migraci√≥n no es solo un ejercicio acad√©mico. Muchas aplicaciones est√°n haciendo esta transici√≥n ahora mismo.
El OldCartService con BehaviorSubject es el patr√≥n cl√°sico de RxJS para estado. Funciona, pero requiere ceremonias. BehaviorSubject para mantener estado, pipe para derivar valores, suscripciones en componentes.
El NewCartService con Signals es refrescantemente simple. El mismo funcionalidad, la mitad del c√≥digo, m√°s f√°cil de entender. No hay pipe, no hay operadores, solo computed values que se actualizan autom√°ticamente.
La comparaci√≥n de totalItems es reveladora. Con RxJS, necesitan pipe y map. Con Signals, computed hace el trabajo. Ambos son reactivos, pero Signals es m√°s directo.
El patr√≥n de actualizaci√≥n tambi√©n difiere. Con BehaviorSubject, obtienen el valor actual, lo modifican, y emiten el nuevo. Con Signals, update recibe una funci√≥n que transforma el valor. Es m√°s funcional, m√°s predecible.
addItem muestra una ventaja de Signals: l√≥gica m√°s compleja es m√°s clara. Verificar si el item existe, actualizar cantidad si existe, agregar si no. Con RxJS ser√≠a m√°s verboso.
La clave de la migraci√≥n es identificar qu√© realmente necesita RxJS. Estado local raramente lo necesita. HTTP siempre lo necesita. Estado global puede ir en cualquier direcci√≥n dependiendo de la complejidad.
No migren todo ciegamente. Eval√∫en cada caso. Si usan operadores RxJS complejos, mant√©nganlo en RxJS. Si es simple estado con derivaciones, Signals es probablemente mejor.
La migraci√≥n puede ser gradual. No necesitan reescribir toda la aplicaci√≥n. Pueden migrar servicio por servicio, componente por componente. Angular soporta ambos paradigmas simult√°neamente.
________________________________________
Diapositiva 21: LAB 4 - Signals con HTTP (5 minutos)
La integraci√≥n de Signals con HTTP es el patr√≥n que usar√°n constantemente en aplicaciones reales.
HttpSignalsService muestra el patr√≥n b√°sico: signals para estado de la petici√≥n (data, loading, error), m√©todo que hace la petici√≥n y actualiza signals. Es simple pero poderoso.
Los computed hasData, hasError, isReady derivan estado √∫til. No necesitan verificar manualmente m√∫ltiples condiciones en el template. isReady les dice si pueden mostrar datos. Es abstracci√≥n √∫til.
fetchData es el patr√≥n est√°ndar. Setear loading true, limpiar error, hacer petici√≥n, actualizar data en success, actualizar error en failure, siempre setear loading false en finalize. Es el ciclo de vida completo de una petici√≥n HTTP.
createResource es un patr√≥n m√°s avanzado, inspirado en React. Encapsula todo el estado y l√≥gica de una petici√≥n en un objeto. Los componentes solo usan resource.data(), resource.loading(), resource.error(). Pueden recargar con resource.reload(). Es encapsulaci√≥n perfecta.
El auto-load en createResource es UX inteligente. Los datos se cargan autom√°ticamente cuando se crea el resource. No necesitan llamar load() manualmente en ngOnInit. Es una cosa menos que recordar.
destroy para limpiar la suscripci√≥n es importante. Signals no necesita cleanup, pero el Observable HTTP s√≠. Es gesti√≥n de recursos responsable.
El template del componente muestra lo limpio que queda. @if para loading, @else if para error, @else para data. No hay async pipe, no hay suscripciones en el template. Solo signals que se leen como funciones.
Este patr√≥n es el futuro del manejo de HTTP en Angular. La potencia de Observables para la petici√≥n, la simplicidad de Signals para el estado.
________________________________________
Diapositiva 22: LAB 4 - Performance y Best Practices (5 minutos)
Las mejores pr√°cticas no son opcionales si quieren aplicaciones performantes y mantenibles.
Signals granulares vs monol√≠ticos es crucial. firstName y lastName separados permiten actualizaciones precisas. Si solo cambia firstName, solo lo que depende de firstName se actualiza. Un signal monol√≠tico user forzar√≠a actualizaci√≥n de todo lo que lo usa, incluso si solo cambi√≥ una propiedad.
computed para valores derivados es mandatorio. Nunca calculen en el template. filteredItems y sortedItems se calculan una vez cuando sus dependencias cambian, no en cada detecci√≥n de cambios. Es la diferencia entre O(n) y O(1) en renders.
Batch updates son autom√°ticos en Signals. Pueden actualizar m√∫ltiples signals sincr√≥nicamente; Angular los agrupa en un solo ciclo de detecci√≥n de cambios. Con RxJS necesitar√≠an schedulers o t√©cnicas complejas.
untrack es su escape hatch. A veces necesitan leer un signal sin crear dependencia. El ejemplo de logging muestra esto: quieren loggear el nombre y la hora, pero no quieren que el effect se re-ejecute cuando la hora cambia.
Signals readonly p√∫blicos son arquitectura limpia. Los consumidores no pueden modificar accidentalmente el estado. Deben pasar por los m√©todos del servicio. Es el mismo principio que getters/setters pero m√°s elegante.
La limpieza de effects con onCleanup es crucial para evitar memory leaks. Si crean timers, event listeners, o cualquier recurso, l√≠mpienlos. Angular no puede hacer esto autom√°ticamente; es su responsabilidad.
La medici√≥n de performance muestra la diferencia cruda. Signals es s√≠ncrono, inmediato. Observables requiere suscripci√≥n, scheduling. Para estado local, Signals es objetivamente m√°s r√°pido.
Estas pr√°cticas no son sugerencias; son requisitos para aplicaciones profesionales. La diferencia entre c√≥digo que funciona y c√≥digo que escala.
________________________________________
Diapositiva 23: Recursos y Referencias (3 minutos)
Los recursos correctos aceleran dram√°ticamente su aprendizaje. Aqu√≠ est√°n los esenciales.
La documentaci√≥n oficial de Angular Signals es su biblia. Est√° excepcionalmente bien escrita, con ejemplos pr√°cticos y casos de uso reales. No es documentaci√≥n seca; es un tutorial interactivo.
RxJS Documentation puede parecer abrumadora, pero la secci√≥n de operadores es oro puro. Cada operador tiene diagramas de m√°rmol que visualizan exactamente qu√© hace. Dediquen tiempo a explorar.
Learn RxJS complementa la documentaci√≥n oficial con ejemplos m√°s elaborados. Cuando la documentaci√≥n oficial les d√© la teor√≠a, Learn RxJS les d√° la pr√°ctica.
RxJS Marbles es diversi√≥n educativa. Pueden crear diagramas de m√°rmol interactivos para entender operadores complejos. Es como un playground para RxJS.
El repositorio del curso no es c√≥digo de juguete. Cada laboratorio est√° production-ready, con tests, documentaci√≥n, mejores pr√°cticas. Pueden usar este c√≥digo como base para sus proyectos reales.
Los scripts npm est√°n optimizados para su aprendizaje. Cada laboratorio se puede ejecutar independientemente. No necesitan hacer todo en orden. Pueden saltar al tema que necesiten.
El comando benchmark es especialmente interesante. Compara performance real entre RxJS y Signals para diferentes casos de uso. Ver√°n con n√∫meros reales cu√°ndo cada uno es m√°s eficiente.
El cheat sheet de migraci√≥n es su gu√≠a r√°pida. BehaviorSubject ‚Üí signal(), Subject ‚Üí signal() + methods. Impr√≠manlo, p√≥nganlo en su escritorio. Es referencia instant√°nea durante migraciones.
________________________________________
Diapositiva 24: Ejercicio Integrador Final (7 minutos)
Este ejercicio final integra todo lo aprendido. Es una aplicaci√≥n completa, no un ejemplo de juguete.
La Todo App que van a construir es el "Hello World" de las aplicaciones modernas, pero elevado al nivel profesional. Combina Signals para estado, computed para derivaciones, effects para persistencia, y toda la arquitectura limpia que aprendieron.
El componente es standalone, moderno. No necesita m√≥dulo. Los imports son expl√≠citos: FormsModule para ngModel, CommonModule para directivas b√°sicas. Es arquitectura simple y clara.
Los signals todos y filter mantienen el estado. No hay BehaviorSubjects, no hay Observables para estado local. Solo signals simples y efectivos. newTodo es string regular porque no necesita ser reactivo; solo se lee cuando agregan un todo.
Los computed activeTodos, completedTodos, filteredTodos son derivaciones autom√°ticas. Cuando todos cambia, se recalculan. Cuando filter cambia, filteredTodos se actualiza. Es reactividad en cascada, autom√°tica y eficiente.
El effect de persistencia es brillante. Cada vez que todos cambia, se guarda en localStorage. No necesitan recordar llamar save(). No necesitan bot√≥n de guardar. Es persistencia transparente y autom√°tica.
El effect de logging es debugging √∫til. En desarrollo, pueden ver en consola c√≥mo cambia el estado. En producci√≥n, lo comentar√≠an o usar√≠an un flag.
ngOnInit carga datos guardados. Es hidrataci√≥n de estado, restauraci√≥n de sesi√≥n. Los usuarios pueden cerrar el navegador y volver, sus todos est√°n ah√≠.
Los m√©todos de modificaci√≥n son limpios. addTodo crea un todo con ID √∫nico (timestamp), lo agrega al array inmutablemente. toggleTodo mapea y modifica solo el todo espec√≠fico. removeTodo filtra. clearCompleted elimina completados. Cada operaci√≥n es predecible y testeable.
El template usa las nuevas directivas de control de flujo. @if en lugar de *ngIf, @for en lugar de *ngFor. Es la sintaxis moderna de Angular 17+. M√°s clara, m√°s performante.
La vinculaci√≥n bidireccional con [(ngModel)] para newTodo muestra que Signals no reemplaza todo. Para inputs de formulario, ngModel sigue siendo √∫til.
Los contadores en los botones de filtro (todos().length, activeTodos().length) se actualizan autom√°ticamente. No hay l√≥gica manual de actualizaci√≥n. Es la promesa de la reactividad cumplida.
Esta aplicaci√≥n, aunque simple en concepto, demuestra arquitectura profesional. Estado centralizado, derivaciones autom√°ticas, persistencia transparente, UI reactiva. Es el patr√≥n que usar√°n en aplicaciones reales, escalado a necesidades m√°s complejas.
________________________________________
Diapositiva 25: Cierre y Q&A (5 minutos)
Felicitaciones. Han completado un viaje intenso por el coraz√≥n de la programaci√≥n reactiva moderna.
Hoy no solo aprendieron sintaxis; absorbieron paradigmas. La asincron√≠a ya no es un misterio sino una herramienta. Entienden callbacks, dominan Promises, y async/await es su segunda naturaleza. Pueden manejar operaciones paralelas, secuenciales, con timeout, con retry. Son maestros de la asincron√≠a.
RxJS pas√≥ de ser intimidante a ser poderoso. Los Observables son sus aliados para manejar streams de datos. Los operadores son sus herramientas especializadas. Pueden transformar, filtrar, combinar, manejar errores. Son programadores reactivos.
Signals es su nueva arma secreta. Para estado local, es m√°s simple que RxJS. Para derivaciones, computed es m√°gico. Para side effects, effects son autom√°ticos. No es reemplazo de RxJS; es complemento perfecto.
La migraci√≥n de RxJS a Signals no es te√≥rica; es pr√°ctica. Saben cu√°ndo migrar, c√≥mo migrar, y m√°s importante, cu√°ndo NO migrar. Son arquitectos que eligen la herramienta correcta para cada trabajo.
El estado global con Signals resuelve uno de los problemas m√°s complejos elegantemente. No necesitan librer√≠as pesadas de state management para casos simples. Signals es suficiente para muchas aplicaciones.
La pr√≥xima sesi√≥n, el jueves 21 de agosto, abordaremos formularios y mejores pr√°cticas. Con el conocimiento reactivo de hoy, los formularios reactivos ser√°n pan comido. Validaciones as√≠ncronas, formularios din√°micos, todo ser√° m√°s claro con su nuevo entendimiento.
Las tareas para casa no son opcionales si quieren solidificar el conocimiento. Migren un componente real de RxJS a Signals. Implementen estado global en un proyecto existente. Creen un formulario que use validaci√≥n as√≠ncrona con Observables. La pr√°ctica convierte conocimiento en habilidad.
Pueden escribirme a jhonny.ramirez@provias.gob.pe con cualquier duda. No hay preguntas tontas cuando est√°n aprendiendo paradigmas nuevos. A veces un peque√±o empuj√≥n desbloquea comprensi√≥n profunda.
Han demostrado dedicaci√≥n y capacidad de absorci√≥n impresionantes. Programaci√≥n reactiva no es f√°cil, pero la dominaron. Signals es nuevo para muchos, pero ya son expertos. Son la nueva generaci√≥n de desarrolladores Angular.
¬°Excelente trabajo! Nos vemos el jueves a las 19:00 para continuar este viaje extraordinario. Hasta entonces, practiquen, experimenten, y disfruten del poder de la programaci√≥n reactiva.
¬°Hasta la pr√≥xima sesi√≥n! üöÄ

