<div class="lab3-container">
  <header class="lab-header">
    <h1>ğŸ”® LAB 3: ANGULAR SIGNALS</h1>
    <p class="subtitle">PROVIAS DESCENTRALIZADO - Angular v18</p>
    <p class="instructor">Instructor: Ing. Jhonny Alexander Ramirez Chiroque</p>
    <div class="revolution-badge">âœ¨ La RevoluciÃ³n Silenciosa âœ¨</div>
  </header>

  <nav class="navigation-tabs">
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'intro'"
      (click)="setActiveTab('intro')">
      ğŸŒŸ IntroducciÃ³n Signals
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'basic'"
      (click)="setActiveTab('basic')">
      ğŸ”¢ Signals BÃ¡sicos
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'computed'"
      (click)="setActiveTab('computed')">
      ğŸ§® Computed Values
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'effects'"
      (click)="setActiveTab('effects')">
      âš¡ Effects
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'vs-rxjs'"
      (click)="setActiveTab('vs-rxjs')">
      âš”ï¸ Signals vs RxJS
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'todo'"
      (click)="setActiveTab('todo')">
      ğŸ“ Todo App Integrador
    </button>
  </nav>

  <main class="lab-content">
    <!-- IntroducciÃ³n -->
    <section *ngIf="activeTab === 'intro'" class="content-section">
      <div class="theory-box">
        <h2>ğŸ¯ Bienvenidos a la Nueva Era</h2>
        <blockquote>
          "Signals es la respuesta de Angular a una pregunta que la comunidad ha estado haciendo por aÃ±os: Â¿puede el manejo de estado ser mÃ¡s simple? RxJS es poderoso pero complejo. Para estado local de componentes, a menudo es excesivo. Signals llena ese vacÃ­o perfectamente."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
        
        <div class="excel-analogy">
          <h3>ğŸ“Š La AnalogÃ­a de Excel</h3>
          <div class="analogy-box">
            <p><strong>Un signal es como una celda en Excel:</strong></p>
            <p>Cambias una celda â†’ Todas las fÃ³rmulas que la usan se recalculan instantÃ¡neamente</p>
            <div class="excel-demo">
              <div class="cell">A1: {{ count() }}</div>
              <div class="arrow">â†’</div>
              <div class="cell">B1: {{ doubled() }} (=A1*2)</div>
              <div class="arrow">â†’</div>
              <div class="cell">C1: {{ isEven() ? 'PAR' : 'IMPAR' }} (=IF(A1%2=0,"PAR","IMPAR"))</div>
            </div>
          </div>
        </div>

        <div class="advantages-grid">
          <div class="advantage-card">
            <h4>ğŸš€ Performance Superior</h4>
            <p>No requiere Zone.js para detecciÃ³n de cambios</p>
          </div>
          <div class="advantage-card">
            <h4>ğŸ¯ Simplicidad</h4>
            <p>No hay Observables que gestionar para estado local</p>
          </div>
          <div class="advantage-card">
            <h4>ğŸ”’ Type-Safe</h4>
            <p>Por defecto sin gimnasia de tipos</p>
          </div>
          <div class="advantage-card">
            <h4>ğŸ§¹ Sin Memory Leaks</h4>
            <p>PrÃ¡cticamente imposibles con Signals</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Signals BÃ¡sicos -->
    <section *ngIf="activeTab === 'basic'" class="content-section">
      <div class="theory-box">
        <h2>ğŸ”¢ Counter Component - Simplicidad Cristalina</h2>
        <blockquote>
          "El CounterComponent es simplicidad cristalina. No hay Subjects, no hay Observables, no hay suscripciones. Solo signals que contienen valores y se actualizan reactivamente."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="counter-demo">
        <div class="counter-display">
          <div class="main-counter">
            <span class="counter-label">Contador:</span>
            <span class="counter-value">{{ count() }}</span>
          </div>
          
          <div class="counter-controls">
            <button class="counter-btn decrement" (click)="decrement()">-1</button>
            <button class="counter-btn reset" (click)="reset()">Reset</button>
            <button class="counter-btn increment" (click)="increment()">+1</button>
          </div>
        </div>

        <div class="derived-values">
          <div class="derived-card">
            <h4>ğŸ”„ Computed Values</h4>
            <div class="values-grid">
              <div class="value-item">
                <span class="label">Doble:</span>
                <span class="value">{{ doubled() }}</span>
              </div>
              <div class="value-item">
                <span class="label">Es Par:</span>
                <span class="value" [class.even]="isEven()" [class.odd]="!isEven()">
                  {{ isEven() ? 'âœ… PAR' : 'âŒ IMPAR' }}
                </span>
              </div>
              <div class="value-item">
                <span class="label">Cuadrado:</span>
                <span class="value">{{ squared() }}</span>
              </div>
            </div>
          </div>
        </div>

        <div class="history-section">
          <h4>ğŸ“š Historial AutomÃ¡tico (Effect)</h4>
          <div class="history-list">
            @for (entry of history(); track entry.id) {
              <div class="history-item">
                <span class="timestamp">{{ entry.timestamp }}</span>
                <span class="value">{{ entry.value }}</span>
              </div>
            }
          </div>
        </div>

        <div class="syntax-explanation">
          <h3>ğŸ’¡ Sintaxis Deliciosamente Simple</h3>
          <div class="syntax-examples">
            <div class="syntax-item">
              <strong>Crear:</strong>
              <code>count = signal(0)</code>
            </div>
            <div class="syntax-item">
              <strong>Leer:</strong>
              <code>count()</code>
            </div>
            <div class="syntax-item">
              <strong>Escribir:</strong>
              <code>count.set(5)</code>
            </div>
            <div class="syntax-item">
              <strong>Actualizar:</strong>
              <code>count.update(v => v + 1)</code>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Computed Values -->
    <section *ngIf="activeTab === 'computed'" class="content-section">
      <div class="theory-box">
        <h2>ğŸ§® Computed - Magia Derivada</h2>
        <blockquote>
          "computed es magia derivada. doubled siempre serÃ¡ el doble de count, automÃ¡ticamente. No necesitan actualizar doubled manualmente cuando count cambia. Es declarativo: describen la relaciÃ³n una vez, Angular la mantiene por siempre."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="computed-demo">
        <div class="user-form">
          <h3>ğŸ‘¤ Demo: Usuario Complejo</h3>
          <div class="form-row">
            <input 
              type="text" 
              [value]="firstName()" 
              (input)="updateFirstName($event)"
              placeholder="Nombre">
            <input 
              type="text" 
              [value]="lastName()" 
              (input)="updateLastName($event)"
              placeholder="Apellido">
          </div>
          <div class="form-row">
            <input 
              type="email" 
              [value]="email()" 
              (input)="updateEmail($event)"
              placeholder="Email">
            <select [value]="role()" (change)="updateRole($event)">
              <option value="user">Usuario</option>
              <option value="admin">Administrador</option>
              <option value="manager">Gerente</option>
            </select>
          </div>
        </div>

        <div class="computed-results">
          <h4>ğŸ”® Valores Computados AutomÃ¡ticamente</h4>
          <div class="computed-grid">
            <div class="computed-card">
              <strong>Nombre Completo:</strong>
              <span>{{ fullName() }}</span>
            </div>
            <div class="computed-card">
              <strong>Iniciales:</strong>
              <span>{{ initials() }}</span>
            </div>
            <div class="computed-card">
              <strong>Email VÃ¡lido:</strong>
              <span [class.valid]="isEmailValid()" [class.invalid]="!isEmailValid()">
                {{ isEmailValid() ? 'âœ… VÃ¡lido' : 'âŒ InvÃ¡lido' }}
              </span>
            </div>
            <div class="computed-card">
              <strong>Dominio Email:</strong>
              <span>{{ emailDomain() }}</span>
            </div>
            <div class="computed-card">
              <strong>Usuario PROVIAS:</strong>
              <span [class.provias]="isProviasUser()">
                {{ isProviasUser() ? 'ğŸ›ï¸ SÃ­' : 'ğŸ¢ No' }}
              </span>
            </div>
            <div class="computed-card">
              <strong>Nivel Acceso:</strong>
              <span [class]="accessLevel()">{{ accessLevel() }}</span>
            </div>
          </div>
        </div>

        <div class="granular-explanation">
          <h3>ğŸ¯ Signals Granulares vs MonolÃ­ticos</h3>
          <div class="comparison-cards">
            <div class="comparison-card good">
              <h4>âœ… GRANULAR (Recomendado)</h4>
              <pre>firstName = signal('Ana');
lastName = signal('GarcÃ­a');</pre>
              <p>Solo se actualiza lo que realmente cambiÃ³</p>
            </div>
            <div class="comparison-card bad">
              <h4>âŒ MONOLÃTICO (Evitar)</h4>
              <pre>user = signal({
  firstName: 'Ana', 
  lastName: 'GarcÃ­a'
});</pre>
              <p>Actualiza todo aunque solo cambie una propiedad</p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Effects -->
    <section *ngIf="activeTab === 'effects'" class="content-section">
      <div class="theory-box">
        <h2>âš¡ Effects - El Puente MÃ¡gico</h2>
        <blockquote>
          "Los effects son el puente entre el mundo reactivo de Signals y el mundo imperativo de side effects. effect es para efectos secundarios. Cada vez que un signal que usa cambia, el effect se re-ejecuta."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="effects-demo">
        <div class="search-effects">
          <h3>ğŸ” Auto-BÃºsqueda con Effects</h3>
          <input 
            class="search-input"
            type="text"
            [value]="searchTerm()"
            (input)="updateSearchTerm($event)"
            placeholder="ğŸ” Buscar usuarios... (min 3 caracteres)">
          
          <div class="search-status" *ngIf="isSearching()">
            ğŸ”„ Buscando automÃ¡ticamente...
          </div>
          
          <div class="search-results" *ngIf="searchResults().length > 0">
            <h4>ğŸ“‹ Resultados ({{ searchResults().length }}):</h4>
            <div class="results-grid">
              @for (user of searchResults(); track user.id) {
                <div class="user-result">
                  <strong>{{ user.name }}</strong>
                  <span>{{ user.email }}</span>
                </div>
              }
            </div>
          </div>
        </div>

        <div class="persistence-demo">
          <h3>ğŸ’¾ Persistencia AutomÃ¡tica</h3>
          <div class="persistence-status">
            <div class="status-indicator" [class.saved]="lastSaved()">
              {{ lastSaved() ? 'ğŸ’¾ Guardado automÃ¡ticamente' : 'â³ Sin guardar' }}
            </div>
            <div class="save-timestamp" *ngIf="lastSaved()">
              Ãšltimo guardado: {{ lastSaved() }}
            </div>
          </div>
        </div>

        <div class="animation-demo">
          <h3>ğŸ¨ Effects con Cleanup</h3>
          <button class="demo-button animate" (click)="triggerAnimation()">
            Activar AnimaciÃ³n
          </button>
          <div class="animation-box" [class.animated]="isAnimating()">
            <div class="floating-element">
              âœ¨ Elemento Animado âœ¨
            </div>
          </div>
        </div>

        <div class="untracked-explanation">
          <h3>ğŸš« UnTracked - Evitando Dependencias Circulares</h3>
          <div class="code-example">
            <pre><code>effect(() => {
  const term = searchTerm();
  
  if (term.length > 3) {
    untracked(() => {
      isLoading.set(true);  // No crea dependencia
      performSearch(term);
    });
  }
});</code></pre>
          </div>
        </div>
      </div>
    </section>

    <!-- Signals vs RxJS -->
    <section *ngIf="activeTab === 'vs-rxjs'" class="content-section">
      <div class="theory-box">
        <h2>âš”ï¸ Signals vs Observables - La DecisiÃ³n Sabia</h2>
        <blockquote>
          "Esta comparaciÃ³n es crucial. No es sobre cuÃ¡l es mejor, sino sobre cuÃ¡ndo usar cada uno. La regla de oro: si pueden resolverlo con Signals, Ãºsenlo. Es mÃ¡s simple. Si necesitan operadores RxJS, timing complejo, o manejan streams de eventos, usen Observables."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="comparison-demo">
        <div class="decision-matrix">
          <h3>ğŸ¯ Matriz de DecisiÃ³n</h3>
          <div class="matrix-grid">
            <div class="matrix-section use-signals">
              <h4>âœ… Usa SIGNALS para:</h4>
              <ul>
                <li>ğŸ  Estado local del componente</li>
                <li>ğŸ”¢ Valores sÃ­ncronos</li>
                <li>ğŸ“Š Derivaciones simples</li>
                <li>ğŸ¨ UI reactiva sin async pipe</li>
                <li>ğŸ§® Contadores, flags, objetos simples</li>
              </ul>
            </div>
            
            <div class="matrix-section use-observables">
              <h4>âœ… Usa OBSERVABLES para:</h4>
              <ul>
                <li>ğŸŒ HTTP requests complejos</li>
                <li>ğŸª Eventos del DOM con transformaciÃ³n</li>
                <li>â° Streams temporales</li>
                <li>ğŸ”§ Cuando necesitas operadores RxJS</li>
                <li>ğŸ” BÃºsquedas con debounce complejo</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="code-comparison">
          <h3>ğŸ“ ComparaciÃ³n de CÃ³digo</h3>
          <div class="code-grid">
            <div class="code-example rxjs-example">
              <h4>ğŸŒŠ Con RxJS (Ceremonioso)</h4>
              <pre><code>// BehaviorSubject pattern
private countSubject = new BehaviorSubject(0);
count$ = this.countSubject.asObservable();

doubled$ = this.count$.pipe(
  map(count => count * 2)
);

// En template
{{ count$ | async }}
{{ doubled$ | async }}</code></pre>
            </div>
            
            <div class="code-example signals-example">
              <h4>âœ¨ Con Signals (Elegante)</h4>
              <pre><code>// Signal pattern
count = signal(0);

doubled = computed(() => this.count() * 2);

// En template
{{ count() }}
{{ doubled() }}</code></pre>
            </div>
          </div>
        </div>

        <div class="interoperability-demo">
          <h3>ğŸŒ‰ Puentes de Interoperabilidad</h3>
          <div class="bridge-examples">
            <div class="bridge-card">
              <h4>Signal â†’ Observable</h4>
              <code>userObservable$ = toObservable(userSignal)</code>
            </div>
            <div class="bridge-card">
              <h4>Observable â†’ Signal</h4>
              <code>dataSignal = toSignal(data$, { initialValue: [] })</code>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Todo App Integrador -->
    <section *ngIf="activeTab === 'todo'" class="content-section">
      <div class="theory-box">
        <h2>ğŸ“ Todo App - Arquitectura Profesional</h2>
        <blockquote>
          "Esta aplicaciÃ³n, aunque simple en concepto, demuestra arquitectura profesional. Estado centralizado, derivaciones automÃ¡ticas, persistencia transparente, UI reactiva."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="todo-app">
        <div class="todo-header">
          <h3>ğŸ“ PROVIAS Todo Manager</h3>
          <div class="add-todo">
            <input 
              class="todo-input"
              type="text"
              [(ngModel)]="newTodo"
              (keydown.enter)="addTodo()"
              placeholder="Â¿QuÃ© necesitas hacer para PROVIAS?">
            <button class="add-btn" (click)="addTodo()" [disabled]="!newTodo.trim()">
              â• Agregar
            </button>
          </div>
        </div>

        <div class="todo-filters">
          <button 
            *ngFor="let filter of filters" 
            class="filter-btn"
            [class.active]="currentFilter() === filter.value"
            (click)="setFilter(filter.value)">
            {{ filter.label }} <span class="count">({{ filter.count() }})</span>
          </button>
        </div>

        <div class="todo-list" *ngIf="filteredTodos().length > 0">
          @for (todo of filteredTodos(); track todo.id) {
            <div class="todo-item" [class.completed]="todo.completed">
              <input 
                type="checkbox"
                [checked]="todo.completed"
                (change)="toggleTodo(todo.id)"
                class="todo-checkbox">
              <span class="todo-text">{{ todo.text }}</span>
              <span class="todo-date">{{ todo.createdAt | date:'short' }}</span>
              <button class="remove-btn" (click)="removeTodo(todo.id)">ğŸ—‘ï¸</button>
            </div>
          }
        </div>

        <div class="todo-actions" *ngIf="todos().length > 0">
          <button 
            class="action-btn clear"
            (click)="clearCompleted()"
            [disabled]="completedTodos().length === 0">
            ğŸ§¹ Limpiar Completados ({{ completedTodos().length }})
          </button>
          <button class="action-btn clear-all" (click)="clearAll()">
            ğŸ—‘ï¸ Limpiar Todo
          </button>
        </div>

        <div class="todo-stats">
          <h4>ğŸ“Š EstadÃ­sticas AutomÃ¡ticas</h4>
          <div class="stats-grid">
            <div class="stat-card">
              <span class="stat-value">{{ todos().length }}</span>
              <span class="stat-label">Total</span>
            </div>
            <div class="stat-card">
              <span class="stat-value">{{ activeTodos().length }}</span>
              <span class="stat-label">Activos</span>
            </div>
            <div class="stat-card">
              <span class="stat-value">{{ completedTodos().length }}</span>
              <span class="stat-label">Completados</span>
            </div>
            <div class="stat-card">
              <span class="stat-value">{{ completionPercentage() }}%</span>
              <span class="stat-label">Progreso</span>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Panel de Info TÃ©cnica -->
  <aside class="tech-panel">
    <h3>âš™ï¸ InformaciÃ³n TÃ©cnica</h3>
    <div class="tech-stats">
      <div class="tech-item">
        <span class="tech-label">Signals Activos:</span>
        <span class="tech-value">{{ getSignalCount() }}</span>
      </div>
      <div class="tech-item">
        <span class="tech-label">Computed Values:</span>
        <span class="tech-value">{{ getComputedCount() }}</span>
      </div>
      <div class="tech-item">
        <span class="tech-label">Effects Ejecutados:</span>
        <span class="tech-value">{{ effectsExecuted() }}</span>
      </div>
    </div>
    
    <div class="performance-note">
      <h4>ğŸš€ Performance</h4>
      <p>Signals es sÃ­ncrono e inmediato. No requiere scheduling como Observables.</p>
    </div>
  </aside>
</div>