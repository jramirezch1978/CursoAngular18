<div class="lab3-container">
  <header class="lab-header">
    <h1>🔮 LAB 3: ANGULAR SIGNALS</h1>
    <p class="subtitle">PROVIAS DESCENTRALIZADO - Angular v18</p>
    <p class="instructor">Instructor: Ing. Jhonny Alexander Ramirez Chiroque</p>
    <div class="revolution-badge">✨ La Revolución Silenciosa ✨</div>
  </header>

  <nav class="navigation-tabs">
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'intro'"
      (click)="setActiveTab('intro')">
      🌟 Introducción Signals
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'basic'"
      (click)="setActiveTab('basic')">
      🔢 Signals Básicos
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'computed'"
      (click)="setActiveTab('computed')">
      🧮 Computed Values
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'effects'"
      (click)="setActiveTab('effects')">
      ⚡ Effects
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'vs-rxjs'"
      (click)="setActiveTab('vs-rxjs')">
      ⚔️ Signals vs RxJS
    </button>
    <button 
      class="tab-button" 
      [class.active]="activeTab === 'todo'"
      (click)="setActiveTab('todo')">
      📝 Todo App Integrador
    </button>
  </nav>

  <main class="lab-content">
    <!-- Introducción -->
    <section *ngIf="activeTab === 'intro'" class="content-section">
      <div class="theory-box">
        <h2>🎯 Bienvenidos a la Nueva Era</h2>
        <blockquote>
          "Signals es la respuesta de Angular a una pregunta que la comunidad ha estado haciendo por años: ¿puede el manejo de estado ser más simple? RxJS es poderoso pero complejo. Para estado local de componentes, a menudo es excesivo. Signals llena ese vacío perfectamente."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
        
        <div class="excel-analogy">
          <h3>📊 La Analogía de Excel</h3>
          <div class="analogy-box">
            <p><strong>Un signal es como una celda en Excel:</strong></p>
            <p>Cambias una celda → Todas las fórmulas que la usan se recalculan instantáneamente</p>
            <div class="excel-demo">
              <div class="cell">A1: {{ count() }}</div>
              <div class="arrow">→</div>
              <div class="cell">B1: {{ doubled() }} (=A1*2)</div>
              <div class="arrow">→</div>
              <div class="cell">C1: {{ isEven() ? 'PAR' : 'IMPAR' }} (=IF(A1%2=0,"PAR","IMPAR"))</div>
            </div>
          </div>
        </div>

        <div class="advantages-grid">
          <div class="advantage-card">
            <h4>🚀 Performance Superior</h4>
            <p>No requiere Zone.js para detección de cambios</p>
          </div>
          <div class="advantage-card">
            <h4>🎯 Simplicidad</h4>
            <p>No hay Observables que gestionar para estado local</p>
          </div>
          <div class="advantage-card">
            <h4>🔒 Type-Safe</h4>
            <p>Por defecto sin gimnasia de tipos</p>
          </div>
          <div class="advantage-card">
            <h4>🧹 Sin Memory Leaks</h4>
            <p>Prácticamente imposibles con Signals</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Signals Básicos -->
    <section *ngIf="activeTab === 'basic'" class="content-section">
      <div class="theory-box">
        <h2>🔢 Counter Component - Simplicidad Cristalina</h2>
        <blockquote>
          "El CounterComponent es simplicidad cristalina. No hay Subjects, no hay Observables, no hay suscripciones. Solo signals que contienen valores y se actualizan reactivamente."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="counter-demo">
        <div class="counter-display">
          <div class="main-counter">
            <span class="counter-label">Contador:</span>
            <span class="counter-value">{{ count() }}</span>
          </div>
          
          <div class="counter-controls">
            <button class="counter-btn decrement" (click)="decrement()">-1</button>
            <button class="counter-btn reset" (click)="reset()">Reset</button>
            <button class="counter-btn increment" (click)="increment()">+1</button>
          </div>
        </div>

        <div class="derived-values">
          <div class="derived-card">
            <h4>🔄 Computed Values</h4>
            <div class="values-grid">
              <div class="value-item">
                <span class="label">Doble:</span>
                <span class="value">{{ doubled() }}</span>
              </div>
              <div class="value-item">
                <span class="label">Es Par:</span>
                <span class="value" [class.even]="isEven()" [class.odd]="!isEven()">
                  {{ isEven() ? '✅ PAR' : '❌ IMPAR' }}
                </span>
              </div>
              <div class="value-item">
                <span class="label">Cuadrado:</span>
                <span class="value">{{ squared() }}</span>
              </div>
            </div>
          </div>
        </div>

        <div class="history-section">
          <h4>📚 Historial Automático (Effect)</h4>
          <div class="history-list">
            @for (entry of history(); track entry.id) {
              <div class="history-item">
                <span class="timestamp">{{ entry.timestamp }}</span>
                <span class="value">{{ entry.value }}</span>
              </div>
            }
          </div>
        </div>

        <div class="syntax-explanation">
          <h3>💡 Sintaxis Deliciosamente Simple</h3>
          <div class="syntax-examples">
            <div class="syntax-item">
              <strong>Crear:</strong>
              <code>count = signal(0)</code>
            </div>
            <div class="syntax-item">
              <strong>Leer:</strong>
              <code>count()</code>
            </div>
            <div class="syntax-item">
              <strong>Escribir:</strong>
              <code>count.set(5)</code>
            </div>
            <div class="syntax-item">
              <strong>Actualizar:</strong>
              <code>count.update(v => v + 1)</code>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Computed Values -->
    <section *ngIf="activeTab === 'computed'" class="content-section">
      <div class="theory-box">
        <h2>🧮 Computed - Magia Derivada</h2>
        <blockquote>
          "computed es magia derivada. doubled siempre será el doble de count, automáticamente. No necesitan actualizar doubled manualmente cuando count cambia. Es declarativo: describen la relación una vez, Angular la mantiene por siempre."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="computed-demo">
        <div class="user-form">
          <h3>👤 Demo: Usuario Complejo</h3>
          <div class="form-row">
            <input 
              type="text" 
              [value]="firstName()" 
              (input)="updateFirstName($event)"
              placeholder="Nombre">
            <input 
              type="text" 
              [value]="lastName()" 
              (input)="updateLastName($event)"
              placeholder="Apellido">
          </div>
          <div class="form-row">
            <input 
              type="email" 
              [value]="email()" 
              (input)="updateEmail($event)"
              placeholder="Email">
            <select [value]="role()" (change)="updateRole($event)">
              <option value="user">Usuario</option>
              <option value="admin">Administrador</option>
              <option value="manager">Gerente</option>
            </select>
          </div>
        </div>

        <div class="computed-results">
          <h4>🔮 Valores Computados Automáticamente</h4>
          <div class="computed-grid">
            <div class="computed-card">
              <strong>Nombre Completo:</strong>
              <span>{{ fullName() }}</span>
            </div>
            <div class="computed-card">
              <strong>Iniciales:</strong>
              <span>{{ initials() }}</span>
            </div>
            <div class="computed-card">
              <strong>Email Válido:</strong>
              <span [class.valid]="isEmailValid()" [class.invalid]="!isEmailValid()">
                {{ isEmailValid() ? '✅ Válido' : '❌ Inválido' }}
              </span>
            </div>
            <div class="computed-card">
              <strong>Dominio Email:</strong>
              <span>{{ emailDomain() }}</span>
            </div>
            <div class="computed-card">
              <strong>Usuario PROVIAS:</strong>
              <span [class.provias]="isProviasUser()">
                {{ isProviasUser() ? '🏛️ Sí' : '🏢 No' }}
              </span>
            </div>
            <div class="computed-card">
              <strong>Nivel Acceso:</strong>
              <span [class]="accessLevel()">{{ accessLevel() }}</span>
            </div>
          </div>
        </div>

        <div class="granular-explanation">
          <h3>🎯 Signals Granulares vs Monolíticos</h3>
          <div class="comparison-cards">
            <div class="comparison-card good">
              <h4>✅ GRANULAR (Recomendado)</h4>
              <pre>firstName = signal('Ana');
lastName = signal('García');</pre>
              <p>Solo se actualiza lo que realmente cambió</p>
            </div>
            <div class="comparison-card bad">
              <h4>❌ MONOLÍTICO (Evitar)</h4>
              <pre>user = signal({
  firstName: 'Ana', 
  lastName: 'García'
});</pre>
              <p>Actualiza todo aunque solo cambie una propiedad</p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Effects -->
    <section *ngIf="activeTab === 'effects'" class="content-section">
      <div class="theory-box">
        <h2>⚡ Effects - El Puente Mágico</h2>
        <blockquote>
          "Los effects son el puente entre el mundo reactivo de Signals y el mundo imperativo de side effects. effect es para efectos secundarios. Cada vez que un signal que usa cambia, el effect se re-ejecuta."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="effects-demo">
        <div class="search-effects">
          <h3>🔍 Auto-Búsqueda con Effects</h3>
          <input 
            class="search-input"
            type="text"
            [value]="searchTerm()"
            (input)="updateSearchTerm($event)"
            placeholder="🔍 Buscar usuarios... (min 3 caracteres)">
          
          <div class="search-status" *ngIf="isSearching()">
            🔄 Buscando automáticamente...
          </div>
          
          <div class="search-results" *ngIf="searchResults().length > 0">
            <h4>📋 Resultados ({{ searchResults().length }}):</h4>
            <div class="results-grid">
              @for (user of searchResults(); track user.id) {
                <div class="user-result">
                  <strong>{{ user.name }}</strong>
                  <span>{{ user.email }}</span>
                </div>
              }
            </div>
          </div>
        </div>

        <div class="persistence-demo">
          <h3>💾 Persistencia Automática</h3>
          <div class="persistence-status">
            <div class="status-indicator" [class.saved]="lastSaved()">
              {{ lastSaved() ? '💾 Guardado automáticamente' : '⏳ Sin guardar' }}
            </div>
            <div class="save-timestamp" *ngIf="lastSaved()">
              Último guardado: {{ lastSaved() }}
            </div>
          </div>
        </div>

        <div class="animation-demo">
          <h3>🎨 Effects con Cleanup</h3>
          <button class="demo-button animate" (click)="triggerAnimation()">
            Activar Animación
          </button>
          <div class="animation-box" [class.animated]="isAnimating()">
            <div class="floating-element">
              ✨ Elemento Animado ✨
            </div>
          </div>
        </div>

        <div class="untracked-explanation">
          <h3>🚫 UnTracked - Evitando Dependencias Circulares</h3>
          <div class="code-example">
            <pre><code>effect(() => {
  const term = searchTerm();
  
  if (term.length > 3) {
    untracked(() => {
      isLoading.set(true);  // No crea dependencia
      performSearch(term);
    });
  }
});</code></pre>
          </div>
        </div>
      </div>
    </section>

    <!-- Signals vs RxJS -->
    <section *ngIf="activeTab === 'vs-rxjs'" class="content-section">
      <div class="theory-box">
        <h2>⚔️ Signals vs Observables - La Decisión Sabia</h2>
        <blockquote>
          "Esta comparación es crucial. No es sobre cuál es mejor, sino sobre cuándo usar cada uno. La regla de oro: si pueden resolverlo con Signals, úsenlo. Es más simple. Si necesitan operadores RxJS, timing complejo, o manejan streams de eventos, usen Observables."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="comparison-demo">
        <div class="decision-matrix">
          <h3>🎯 Matriz de Decisión</h3>
          <div class="matrix-grid">
            <div class="matrix-section use-signals">
              <h4>✅ Usa SIGNALS para:</h4>
              <ul>
                <li>🏠 Estado local del componente</li>
                <li>🔢 Valores síncronos</li>
                <li>📊 Derivaciones simples</li>
                <li>🎨 UI reactiva sin async pipe</li>
                <li>🧮 Contadores, flags, objetos simples</li>
              </ul>
            </div>
            
            <div class="matrix-section use-observables">
              <h4>✅ Usa OBSERVABLES para:</h4>
              <ul>
                <li>🌐 HTTP requests complejos</li>
                <li>🎪 Eventos del DOM con transformación</li>
                <li>⏰ Streams temporales</li>
                <li>🔧 Cuando necesitas operadores RxJS</li>
                <li>🔍 Búsquedas con debounce complejo</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="code-comparison">
          <h3>📝 Comparación de Código</h3>
          <div class="code-grid">
            <div class="code-example rxjs-example">
              <h4>🌊 Con RxJS (Ceremonioso)</h4>
              <pre><code>// BehaviorSubject pattern
private countSubject = new BehaviorSubject(0);
count$ = this.countSubject.asObservable();

doubled$ = this.count$.pipe(
  map(count => count * 2)
);

// En template
{{ count$ | async }}
{{ doubled$ | async }}</code></pre>
            </div>
            
            <div class="code-example signals-example">
              <h4>✨ Con Signals (Elegante)</h4>
              <pre><code>// Signal pattern
count = signal(0);

doubled = computed(() => this.count() * 2);

// En template
{{ count() }}
{{ doubled() }}</code></pre>
            </div>
          </div>
        </div>

        <div class="interoperability-demo">
          <h3>🌉 Puentes de Interoperabilidad</h3>
          <div class="bridge-examples">
            <div class="bridge-card">
              <h4>Signal → Observable</h4>
              <code>userObservable$ = toObservable(userSignal)</code>
            </div>
            <div class="bridge-card">
              <h4>Observable → Signal</h4>
              <code>dataSignal = toSignal(data$, { initialValue: [] })</code>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Todo App Integrador -->
    <section *ngIf="activeTab === 'todo'" class="content-section">
      <div class="theory-box">
        <h2>📝 Todo App - Arquitectura Profesional</h2>
        <blockquote>
          "Esta aplicación, aunque simple en concepto, demuestra arquitectura profesional. Estado centralizado, derivaciones automáticas, persistencia transparente, UI reactiva."
          <footer>- Ing. Jhonny Ramirez</footer>
        </blockquote>
      </div>

      <div class="todo-app">
        <div class="todo-header">
          <h3>📝 PROVIAS Todo Manager</h3>
          <div class="add-todo">
            <input 
              class="todo-input"
              type="text"
              [(ngModel)]="newTodo"
              (keydown.enter)="addTodo()"
              placeholder="¿Qué necesitas hacer para PROVIAS?">
            <button class="add-btn" (click)="addTodo()" [disabled]="!newTodo.trim()">
              ➕ Agregar
            </button>
          </div>
        </div>

        <div class="todo-filters">
          <button 
            *ngFor="let filter of filters" 
            class="filter-btn"
            [class.active]="currentFilter() === filter.value"
            (click)="setFilter(filter.value)">
            {{ filter.label }} <span class="count">({{ filter.count() }})</span>
          </button>
        </div>

        <div class="todo-list" *ngIf="filteredTodos().length > 0">
          @for (todo of filteredTodos(); track todo.id) {
            <div class="todo-item" [class.completed]="todo.completed">
              <input 
                type="checkbox"
                [checked]="todo.completed"
                (change)="toggleTodo(todo.id)"
                class="todo-checkbox">
              <span class="todo-text">{{ todo.text }}</span>
              <span class="todo-date">{{ todo.createdAt | date:'short' }}</span>
              <button class="remove-btn" (click)="removeTodo(todo.id)">🗑️</button>
            </div>
          }
        </div>

        <div class="todo-actions" *ngIf="todos().length > 0">
          <button 
            class="action-btn clear"
            (click)="clearCompleted()"
            [disabled]="completedTodos().length === 0">
            🧹 Limpiar Completados ({{ completedTodos().length }})
          </button>
          <button class="action-btn clear-all" (click)="clearAll()">
            🗑️ Limpiar Todo
          </button>
        </div>

        <div class="todo-stats">
          <h4>📊 Estadísticas Automáticas</h4>
          <div class="stats-grid">
            <div class="stat-card">
              <span class="stat-value">{{ todos().length }}</span>
              <span class="stat-label">Total</span>
            </div>
            <div class="stat-card">
              <span class="stat-value">{{ activeTodos().length }}</span>
              <span class="stat-label">Activos</span>
            </div>
            <div class="stat-card">
              <span class="stat-value">{{ completedTodos().length }}</span>
              <span class="stat-label">Completados</span>
            </div>
            <div class="stat-card">
              <span class="stat-value">{{ completionPercentage() }}%</span>
              <span class="stat-label">Progreso</span>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Panel de Info Técnica -->
  <aside class="tech-panel">
    <h3>⚙️ Información Técnica</h3>
    <div class="tech-stats">
      <div class="tech-item">
        <span class="tech-label">Signals Activos:</span>
        <span class="tech-value">{{ getSignalCount() }}</span>
      </div>
      <div class="tech-item">
        <span class="tech-label">Computed Values:</span>
        <span class="tech-value">{{ getComputedCount() }}</span>
      </div>
      <div class="tech-item">
        <span class="tech-label">Effects Ejecutados:</span>
        <span class="tech-value">{{ effectsExecuted() }}</span>
      </div>
    </div>
    
    <div class="performance-note">
      <h4>🚀 Performance</h4>
      <p>Signals es síncrono e inmediato. No requiere scheduling como Observables.</p>
    </div>
  </aside>
</div>