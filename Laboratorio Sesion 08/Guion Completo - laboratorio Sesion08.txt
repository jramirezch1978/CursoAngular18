GUI√ìN DETALLADO - SESI√ìN 08: MEJORES PR√ÅCTICAS Y FORMULARIOS
PROVIAS DESCENTRALIZADO
________________________________________
Diapositiva 1: Car√°tula (2 minutos)
Muy buenas noches a todos. Bienvenidos a la sesi√≥n 8 de nuestro curso Angular 18, una sesi√≥n que transformar√° completamente c√≥mo construyen formularios y aplican mejores pr√°cticas en sus aplicaciones.
Mi nombre es Jhonny Alexander Ramirez Chiroque y hoy jueves 21 de agosto de 2025, vamos a dominar uno de los aspectos m√°s cr√≠ticos pero a menudo subestimados del desarrollo web: los formularios. Si piensan que los formularios son aburridos, prep√°rense para cambiar de opini√≥n.
Imaginen por un momento que est√°n dise√±ando el sistema de registro para la nueva plataforma digital de PROVIAS. Miles de usuarios ingresar√°n datos cr√≠ticos: informaci√≥n personal, documentos, coordenadas de proyectos. Un formulario mal dise√±ado no solo frustra usuarios; puede comprometer la integridad de datos de toda la organizaci√≥n. Un formulario bien dise√±ado es invisible: los usuarios completan su tarea sin siquiera notar la complejidad que manejan por detr√°s.
Esta sesi√≥n es 100% pr√°ctica. No vamos a filosofar sobre formularios; vamos a construirlos, validarlos, asegurarlos y optimizarlos. Van a escribir c√≥digo que no solo funciona, sino que es seguro, accesible y performante. C√≥digo del que pueden estar orgullosos.
Angular 18 nos ofrece dos caminos para formularios: Template-driven para simplicidad y Reactive para control total. Hoy dominar√°n ambos y, m√°s importante, sabr√°n exactamente cu√°ndo usar cada uno. Tambi√©n implementaremos seguridad real contra ataques XSS y CSRF, optimizaremos rendimiento con OnPush y Lazy Loading, y haremos nuestras aplicaciones accesibles para todos.
Preparen sus editores, abran sus terminales, y prep√°rense para tres horas intensivas que elevar√°n la calidad de sus aplicaciones al nivel profesional que sus usuarios merecen.
________________________________________
Diapositiva 2: Objetivos de la Sesi√≥n (2 minutos)
Los objetivos de hoy van m√°s all√° de simplemente crear formularios. Vamos a transformar c√≥mo piensan sobre la interacci√≥n usuario-aplicaci√≥n.
Crear formularios tanto Template-driven como Reactive es como aprender a conducir tanto autom√°tico como manual. Cada uno tiene su lugar, sus ventajas, sus casos de uso ideales. No es sobre cu√°l es mejor; es sobre cu√°l es correcto para cada situaci√≥n.
Implementar validaciones personalizadas y as√≠ncronas es donde la magia ocurre. Es como tener un asistente inteligente que verifica en tiempo real si el RUC ingresado existe en SUNAT, si el email ya est√° registrado, si las coordenadas corresponden a una ubicaci√≥n v√°lida en Per√∫. No m√°s formularios que fallan al enviar despu√©s de 10 minutos llen√°ndolos.
La seguridad no es opcional. Cada d√≠a, aplicaciones son comprometidas por ataques XSS y CSRF. Aprender√°n a blindar sus formularios como si fueran la b√≥veda de un banco. Sus usuarios conf√≠an en ustedes con sus datos; esa confianza es sagrada.
Optimizar el rendimiento con OnPush y Lazy Loading es la diferencia entre una aplicaci√≥n que se siente moderna y una que se siente del 2010. Es como la diferencia entre usar Waze con actualizaci√≥n en tiempo real versus un mapa de papel: ambos te llevan al destino, pero la experiencia es incomparable.
El manejo profesional de errores transforma frustraci√≥n en comprensi√≥n. En lugar de "Error: undefined", sus usuarios ver√°n "El DNI debe contener exactamente 8 d√≠gitos". Es empat√≠a codificada.
La accesibilidad no es un extra; es un derecho. Sus formularios funcionar√°n para usuarios con discapacidades visuales, motoras, cognitivas. Es inclusi√≥n a trav√©s del c√≥digo.
Las pruebas b√°sicas con Jasmine y Karma son su red de seguridad. Cada cambio que hagan estar√° respaldado por tests que confirman que nada se rompi√≥. Es dormir tranquilo sabiendo que su c√≥digo es s√≥lido.
________________________________________
Diapositiva 3: Agenda (1 minuto)
Nuestra agenda est√° dise√±ada como un crescendo musical, cada laboratorio construyendo sobre el anterior.
Los primeros 45 minutos establecer√°n los fundamentos. Exploraremos la filosof√≠a detr√°s de Template-driven versus Reactive Forms. Es como elegir entre un smartphone con interfaz simplificada versus uno con modo desarrollador: ambos son poderosos, pero sirven diferentes necesidades.
Los siguientes 45 minutos son pura construcci√≥n con Reactive Forms. Aqu√≠ es donde el poder real se desata. FormBuilder ser√° su mejor amigo, las validaciones ser√°n su armadura.
Nuestro break de 15 minutos es estrat√©gico. Los conceptos de formularios reactivos son densos. Su cerebro necesita tiempo para procesar y consolidar antes de avanzar a territorio m√°s complejo.
El tercer bloque de 45 minutos es donde nos volvemos ninjas. Validaciones personalizadas que verifican CUIPs, validaciones as√≠ncronas que consultan APIs, formularios din√°micos que se adaptan seg√∫n las respuestas del usuario.
Los √∫ltimos 25 minutos son sobre excelencia. Seguridad que protege, performance que deleita, accesibilidad que incluye. Es la diferencia entre c√≥digo que funciona y c√≥digo profesional.
Cada minuto est√° optimizado. No hay relleno, solo conocimiento aplicable que usar√°n ma√±ana mismo en sus proyectos.
________________________________________
Diapositiva 4: Introducci√≥n a Formularios (3 minutos)
Bienvenidos al mundo de los formularios en Angular, donde la recolecci√≥n de datos se convierte en arte.
Los formularios son el puente entre sus usuarios y su aplicaci√≥n. Son como las ventanillas de atenci√≥n en una oficina: si est√°n bien dise√±adas, el flujo es eficiente y placentero. Si est√°n mal dise√±adas, generan colas, frustraci√≥n y abandono.
Template-driven Forms es el enfoque cl√°sico, intuitivo. La l√≥gica vive en el HTML, usa directivas como ngModel para binding bidireccional. Es como llenar un formulario f√≠sico: lo que ves es lo que obtienes. Perfecto cuando necesitan algo r√°pido, simple, sin complicaciones.
Piensen en un formulario de contacto b√°sico: nombre, email, mensaje. Template-driven es perfecto aqu√≠. No necesitan artillery pesada para capturar tres campos. Es como usar una bicicleta para ir a la tienda de la esquina: simple, eficiente, apropiado.
Reactive Forms es el enfoque program√°tico, poderoso. La l√≥gica vive en TypeScript, tienen control total sobre el estado del formulario. Es como tener un asistente personal que no solo recoge informaci√≥n, sino que la valida, la transforma, la prepara exactamente como la necesitan.
Imaginen un formulario de registro de proyecto en PROVIAS: m√∫ltiples secciones, validaciones cruzadas entre fechas de inicio y fin, presupuestos que deben sumar correctamente, anexos que dependen del tipo de proyecto. Aqu√≠ Reactive Forms brilla. Tienen control quir√∫rgico sobre cada aspecto.
La regla de oro es simple: si pueden dibujarlo en una servilleta, probablemente Template-driven es suficiente. Si necesitan un diagrama de flujo para explicarlo, Reactive Forms es su amigo.
No es una decisi√≥n permanente. Pueden tener formularios Template-driven y Reactive en la misma aplicaci√≥n. Usen la herramienta correcta para cada trabajo.
________________________________________
Diapositiva 5: Template-driven Forms (4 minutos)
Profundicemos en Template-driven Forms y entendamos por qu√©, a pesar de ser "simple", sigue siendo poderoso.
Las ventajas son tangibles e inmediatas. Es f√°cil de aprender porque se parece a HTML tradicional con superpoderes. Si vienen de otros frameworks o incluso de desarrollo web cl√°sico, se sentir√°n en casa inmediatamente.
Menos c√≥digo TypeScript significa menos superficie para bugs. El componente queda limpio, enfocado en l√≥gica de negocio, no en gesti√≥n de formularios. Es como tener un asistente que se encarga del papeleo mientras ustedes se enfocan en decisiones importantes.
Para formularios simples, es imbatible. Un formulario de login, una encuesta de satisfacci√≥n, un formulario de b√∫squeda. No necesitan un ca√±√≥n para matar una mosca. Template-driven es su matamoscas elegante.
El binding autom√°tico con ngModel es magia conveniente. Escriben en el input, el modelo se actualiza. Cambian el modelo, el input refleja el cambio. Es sincronizaci√≥n sin esfuerzo, como tener espejos que siempre reflejan la realidad actual.
Pero las desventajas son reales y deben considerarlas. Testing unitario es m√°s dif√≠cil porque la l√≥gica est√° en el template. No pueden simplemente instanciar el componente y probar m√©todos; necesitan el template renderizado.
El menor control sobre el estado puede ser frustrante en escenarios complejos. Es como conducir un auto autom√°tico en una pista de carreras: funciona, pero no tienen el control fino que necesitan para optimizar cada curva.
Las validaciones est√°n limitadas a lo que Angular ofrece o a directivas personalizadas. No pueden f√°cilmente implementar validaci√≥n condicional compleja o validaciones que dependen de servicios externos.
La escalabilidad es el tal√≥n de Aquiles. Un formulario de 50 campos con validaciones cruzadas, secciones condicionales y l√≥gica compleja se vuelve un monstruo en Template-driven. El template se vuelve ilegible, la l√≥gica se esparce, el mantenimiento se vuelve pesadilla.
________________________________________
Diapositiva 6: Estructura Template-driven (3 minutos)
Analicemos la anatom√≠a de un Template-driven Form para entender c√≥mo funciona bajo el cap√≥.
ngForm es el director de orquesta. Autom√°ticamente se aplica a cualquier tag form y crea una instancia de FormGroup internamente. Es como el gerente de una oficina: coordina todo pero ustedes raramente interact√∫an directamente con √©l.
ngModel es su caballo de batalla. Crea el binding bidireccional, pero tambi√©n hace m√°s: registra el control con ngForm, aplica validaciones, trackea el estado. Es como un empleado multitarea que no solo recoge datos sino que los valida y organiza.
El atributo name es cr√≠tico y a menudo olvidado. Sin √©l, ngModel no puede registrar el control correctamente. Es como intentar archivar documentos sin etiquetas: todo se vuelve un caos. Cada input necesita un name √∫nico dentro del formulario.
Las referencias locales con # son su ventana al estado del formulario. #myForm="ngForm" les da acceso al formulario completo. #nameInput="ngModel" les da acceso a un control espec√≠fico. Es como tener acceso directo a reportes de estado en tiempo real.
Los estados del formulario son su sistema de sem√°foros. Pristine/dirty les dice si el usuario ha interacturado. Es como saber si un documento ha sido modificado desde que se abri√≥. Valid/invalid es su luz roja/verde para proceder. Touched/untouched indica si el campo ha tenido foco, √∫til para mostrar errores solo despu√©s de interacci√≥n.
Estos estados no son solo booleanos; son inteligencia que pueden usar. Mostrar errores solo cuando touched evita abrumar al usuario con rojo antes de que empiece. Deshabilitar el bot√≥n submit cuando invalid previene env√≠os incorrectos. Es UX inteligente basada en estado.
________________________________________
Diapositiva 7: Ejemplo Template-driven (4 minutos)
Veamos un ejemplo pr√°ctico que pueden implementar inmediatamente en sus proyectos.
El ContactComponent es simplicidad elegante. El modelo es un objeto plano con las propiedades del formulario. No hay FormGroups, no hay FormControls, solo un objeto JavaScript simple. Es como tener un formulario de papel que m√°gicamente se digitaliza.
En el TypeScript, la magia es m√≠nima. Definen el modelo con valores iniciales vac√≠os. El m√©todo onSubmit simplemente toma el modelo actual y hace algo con √©l. En este caso, un console.log, pero en la vida real ser√≠a una llamada HTTP a su backend.
El template es donde ocurre la acci√≥n. La referencia #contactForm="ngForm" captura el formulario completo. Esto les da acceso a contactForm.valid, contactForm.pristine, y todos los estados que necesiten.
El binding [(ngModel)]="model.name" es bidireccional. Los par√©ntesis cuadrados [] son property binding (modelo hacia vista). Los par√©ntesis normales () son event binding (vista hacia modelo). Juntos [()] crean el two-way binding. Es como un walkie-talkie: habla en ambas direcciones.
El atributo required es validaci√≥n declarativa. Angular autom√°ticamente valida que el campo no est√© vac√≠o. Pueden agregar minlength, maxlength, pattern, email. Son validaciones HTML5 mejoradas por Angular.
El bot√≥n [disabled]="!contactForm.valid" es UX inteligente. No pueden enviar hasta que todo est√© correcto. Es como un cajero autom√°tico que no les deja continuar hasta que ingresen un PIN v√°lido.
Este patr√≥n escala hasta cierto punto. Pueden agregar m√°s campos, m√°s validaciones b√°sicas. Pero cuando necesiten validaci√≥n cruzada entre campos, validaci√≥n as√≠ncrona, o l√≥gica condicional compleja, es hora de considerar Reactive Forms.
________________________________________
Diapositiva 8: Reactive Forms Introducci√≥n (3 minutos)
Ahora entramos al territorio de Reactive Forms, donde el control y la flexibilidad son absolutos.
La programaci√≥n reactiva en formularios es un cambio de paradigma. Ya no est√°n describiendo qu√© es el formulario en el template; est√°n programando c√≥mo se comporta en TypeScript. Es como la diferencia entre dar instrucciones paso a paso versus programar un GPS que se adapta din√°micamente.
FormControl es el √°tomo de Reactive Forms. Representa un √∫nico campo con su valor, validaciones y estado. Es como una celda en Excel: tiene un valor, puede tener f√≥rmulas (validaciones), y sabe su estado (v√°lido, modificado, etc.).
FormGroup es la mol√©cula. Agrupa m√∫ltiples FormControls en una estructura coherente. Es como una secci√≥n de un formulario: datos personales, direcci√≥n, informaci√≥n laboral. Cada grupo puede validarse independientemente y como conjunto.
FormArray es la estructura din√°mica. Perfecta para listas de items donde no saben cu√°ntos habr√°. Es como las l√≠neas de detalle en una factura: pueden ser 1 o 100, FormArray las maneja todas.
FormBuilder es su asistente de construcci√≥n. Reduce el boilerplate, hace el c√≥digo m√°s legible. Es como usar una plantilla predise√±ada versus dibujar desde cero: mismo resultado, menos trabajo.
El principio fundamental es que el estado vive en el componente. El template es solo una vista de ese estado. Es como MVC cl√°sico: el modelo (FormGroup) est√° separado de la vista (template). Esto hace testing trivial, reutilizaci√≥n simple, y mantenimiento placentero.
El flujo unidireccional modelo‚Üívista es predecible. No hay sorpresas, no hay binding m√°gico que no entiendan. Ustedes controlan exactamente cu√°ndo y c√≥mo el estado se actualiza.
________________________________________
Diapositiva 9: FormControl y FormGroup (4 minutos)
Profundicemos en los bloques fundamentales de construcci√≥n de Reactive Forms.
FormControl es sorprendentemente poderoso para algo tan simple. Cuando crean new FormControl('Juan'), no solo est√°n guardando un string. Est√°n creando un objeto rico que trackea valor, validaciones, estado, y emite eventos cuando cambia.
El m√©todo .value les da el valor actual. Simple, directo. Pero tambi√©n tienen .valid, .invalid, .pristine, .dirty, .touched, .untouched. Cada property cuenta una parte de la historia del campo.
.setValue() es actualizaci√≥n directa. Reemplaza el valor completamente. Pero tambi√©n tienen .patchValue() para actualizaciones parciales, .reset() para volver al estado inicial, .disable() y .enable() para control de interacci√≥n.
FormGroup eleva esto al siguiente nivel. Cuando crean un FormGroup con m√∫ltiples FormControls, est√°n creando una jerarqu√≠a. Es como un organigrama: el FormGroup es el departamento, los FormControls son los empleados. Pueden gestionar a nivel individual o departamental.
La belleza est√° en la composici√≥n. Pueden tener FormGroups dentro de FormGroups. Un formulario de empleado puede tener un FormGroup para datos personales, otro para direcci√≥n, otro para informaci√≥n laboral. Cada uno con sus propias validaciones y l√≥gica.
El acceso a controles es flexible. userForm.get('name') obtiene el FormControl por path. Pueden incluso hacer userForm.get('address.street') para navegaci√≥n profunda. Es como acceder a propiedades de objetos JavaScript, familiar y poderoso.
Los FormGroups tambi√©n emiten eventos. .valueChanges es un Observable que emite cada vez que cualquier control cambia. .statusChanges emite cuando el estado de validaci√≥n cambia. Pueden reaccionar a estos cambios, implementar autoguardado, validaci√≥n en tiempo real, lo que imaginen.
________________________________________
Diapositiva 10: FormBuilder Service (3 minutos)
FormBuilder es su mejor amigo para construir formularios complejos sin el boilerplate.
Sin FormBuilder, el c√≥digo es verboso. Cada FormControl necesita new FormControl(), cada FormGroup necesita new FormGroup(). Es como escribir HTML sin emmet: funciona, pero es tedioso.
Con FormBuilder, el c√≥digo es poes√≠a. this.fb.group({}) es m√°s limpio que new FormGroup({}). Pero la verdadera magia est√° en la sintaxis de array para controles con validaciones.
Cuando escriben name: ['Juan', Validators.required], FormBuilder entiende que el primer elemento es el valor inicial, el segundo son las validaciones s√≠ncronas. Pueden incluso agregar un tercer elemento para validaciones as√≠ncronas: ['', Validators.required, this.checkUsername.bind(this)].
FormBuilder tambi√©n simplifica grupos anidados. En lugar de crear FormGroups separados y anidarlos manualmente, simplemente anidan las llamadas a .group(). Es composici√≥n natural, como escribir JSON.
La ventaja no es solo menos c√≥digo; es c√≥digo m√°s mantenible. Cuando miran un formulario construido con FormBuilder, inmediatamente ven la estructura. Es autodocumentado. Un nuevo desarrollador puede entender el formulario en segundos, no minutos.
FormBuilder tambi√©n tiene .array() para FormArrays y .control() para FormControls individuales. Es una API consistente para todas las necesidades de construcci√≥n de formularios.
El patr√≥n de inyectar FormBuilder en el constructor es est√°ndar. constructor(private fb: FormBuilder) {} y est√°n listos. No necesitan importar FormControl, FormGroup, FormArray en cada componente. FormBuilder los abstrae todos.
________________________________________
Diapositiva 11: Validaciones Built-in (4 minutos)
Angular viene con un arsenal de validadores listos para usar. Conozc√°moslos √≠ntimamente.
Validators.required es el m√°s b√°sico pero m√°s usado. Es el "este campo es obligatorio" universal. Pero no subestimen su importancia: campos requeridos mal manejados son la primera fuente de frustraci√≥n de usuarios.
Validators.email es validaci√≥n de formato de email. No verifica si el email existe, solo si tiene formato v√°lido. Es como verificar que un n√∫mero de tel√©fono tenga el formato correcto, no que el n√∫mero exista.
Validators.minLength y maxLength son para strings. minLength(3) requiere al menos 3 caracteres. Perfecto para usernames, passwords, descripciones. No confundan con min/max que son para n√∫meros.
Validators.pattern es su navaja suiza. Acepta expresiones regulares para validaci√≥n personalizada. pattern('[0-9]{8}') valida exactamente 8 d√≠gitos, perfecto para DNI peruano. pattern('^[A-Z]{2}[0-9]{4}$') podr√≠a validar c√≥digos de proyecto.
Validators.min y max son para valores num√©ricos. min(18) para edad m√≠nima, max(100) para porcentajes. √ötiles en formularios financieros, configuraci√≥n de par√°metros, rangos de fechas convertidas a n√∫meros.
La composici√≥n de validadores es poderosa. [Validators.required, Validators.email] requiere un campo y que sea email v√°lido. Angular ejecuta todos los validadores y acumula los errores. Si cualquiera falla, el campo es inv√°lido.
El orden importa para UX. Pongan Validators.required primero para que sea el primer error que vean los usuarios. No tiene sentido decirles que el formato de email es incorrecto si el campo est√° vac√≠o.
Estos validadores cubren 80% de los casos. Para el 20% restante, necesitar√°n validadores personalizados, que veremos pronto.
________________________________________
Diapositiva 12: Estados y Errores (4 minutos)
El manejo inteligente de estados y errores transforma un formulario funcional en uno profesional.
Los estados booleanos son su sistema de informaci√≥n. Valid/invalid es obvio, pero pristine/dirty es sutil y poderoso. Pristine significa que el usuario no ha modificado el valor inicial. √ötil para prevenir mensajes de "cambios no guardados" cuando nada cambi√≥.
Touched/untouched indica interacci√≥n f√≠sica. Un campo se vuelve touched cuando pierde el foco (blur event). Esto es crucial para UX: no muestren errores en campos que el usuario a√∫n no ha visitado. Es como no corregir a alguien mientras est√° hablando.
Enabled/disabled controla interactividad. Pueden deshabilitar campos basados en l√≥gica de negocio. Por ejemplo, deshabilitar el campo de descuento si el usuario no es premium. .disable() y .enable() lo controlan program√°ticamente.
El objeto errors es donde vive la inteligencia de validaci√≥n. Cuando un validador falla, agrega una propiedad al objeto errors. control.errors['required'] es true si falta el campo. control.errors['minlength'] contiene informaci√≥n adicional como la longitud actual y la requerida.
El patr√≥n de chequeo es importante. Siempre verifiquen primero si errors existe: if (control.errors). Luego accedan a errores espec√≠ficos. Esto previene errores de "cannot read property of null".
Los errores personalizados siguen el mismo patr√≥n. Si su validador retorna {invalidDni: true}, pueden checkearlo con control.errors['invalidDni']. Consistencia en el manejo de errores hace el c√≥digo predecible.
La priorizaci√≥n de errores mejora UX. Si un campo tiene m√∫ltiples errores, muestren el m√°s importante primero. Required antes que formato, formato antes que l√≥gica de negocio. Gu√≠en al usuario paso a paso, no lo abrumen con todos los errores de una vez.
________________________________________
Diapositiva 13: Reactive Form Completo (5 minutos)
Construyamos un formulario completo que demuestre el poder de Reactive Forms en acci√≥n.
El userForm que creamos es un ejemplo del mundo real. Cada campo tiene validaciones apropiadas que trabajan juntas para asegurar datos de calidad.
El campo name requiere m√≠nimo 3 caracteres. Esto previene nombres de una letra o iniciales cuando necesitan nombres completos. La combinaci√≥n de required y minLength asegura datos significativos.
El campo email usa validaci√≥n doble: requerido y formato v√°lido. Noten c√≥mo usamos arrays para m√∫ltiples validadores. Angular los ejecuta en orden y acumula errores.
El campo age demuestra validadores num√©ricos. Min(18) asegura mayor√≠a de edad, max(100) previene edades irreales. El valor inicial null es intencional: muestra placeholder sin pre-llenar con 0.
El getter get name() es un patr√≥n crucial. En lugar de escribir userForm.get('name') en todo el template, crean un getter limpio. Es como crear un atajo que hace el template m√°s legible.
En el template, [formGroup]="userForm" conecta el formulario HTML con el FormGroup TypeScript. Es el puente entre modelo y vista. Sin esto, nada funciona.
formControlName="name" conecta cada input con su FormControl. Noten que no usan corchetes []. formControlName espera un string literal, no una expresi√≥n.
La validaci√≥n condicional *ngIf="name?.invalid && name?.touched" es UX profesional. Solo muestran errores despu√©s de que el usuario interactu√≥ con el campo. El operador ?. previene errores si name es null.
Este patr√≥n escala hermosamente. Pueden agregar campos, validaciones complejas, l√≥gica condicional. El componente permanece organizado, el template limpio, las responsabilidades claras.
________________________________________
Diapositiva 14: BREAK (15 minutos)
Excelente trabajo hasta aqu√≠. Han absorbido conceptos fundamentales que transformar√°n c√≥mo construyen formularios.
Han visto la simplicidad de Template-driven forms y el poder de Reactive forms. Ya no es un misterio cu√°ndo usar cada uno. Tienen criterios claros basados en complejidad y requisitos.
FormControl, FormGroup y FormBuilder ya no son abstracciones confusas. Son herramientas concretas que pueden usar ma√±ana mismo. Saben c√≥mo construir formularios complejos con c√≥digo limpio y mantenible.
Las validaciones b√°sicas que dominaron cubren la mayor√≠a de casos reales. Required, email, minLength, pattern... cada una tiene su lugar. Y saben c√≥mo combinarlas para validaci√≥n comprensiva.
El manejo de estados y errores que aprendieron separa formularios amateur de profesionales. Sus usuarios ver√°n mensajes √∫tiles en el momento correcto, no un mar de rojo apenas cargan la p√°gina.
Durante este break, reflexionen sobre los formularios en sus aplicaciones actuales. ¬øCu√°les podr√≠an beneficiarse de migrar a Reactive Forms? ¬øD√≥nde podr√≠an mejorar la validaci√≥n y manejo de errores?
Hidr√°tense bien. La segunda mitad es intensa: validaciones personalizadas que pueden verificar cualquier regla de negocio, validaciones as√≠ncronas que consultan servicios externos, y mejores pr√°cticas de seguridad y performance.
Tambi√©n cubriremos accesibilidad, asegurando que sus formularios funcionen para todos los usuarios, sin importar sus capacidades. Es desarrollo inclusivo y es m√°s simple de lo que piensan.
Nos vemos en 15 minutos, a las 20:45. Regresen con energ√≠a porque vamos a llevar sus habilidades de formularios al siguiente nivel.
________________________________________
Diapositiva 15: Validaciones Personalizadas (4 minutos)
Bienvenidos de vuelta. Ahora aprender√°n a crear validadores que resuelven sus necesidades espec√≠ficas de negocio.
Un validador personalizado es simplemente una funci√≥n que recibe un AbstractControl y retorna ValidationErrors o null. Si retorna null, el campo es v√°lido. Si retorna un objeto, el campo es inv√°lido y el objeto describe el error.
La estructura es elegante en su simplicidad. La funci√≥n recibe el control, examina su valor, aplica la l√≥gica de validaci√≥n, y retorna el resultado. Es como un inspector de calidad en una l√≠nea de producci√≥n: examina, decide, marca.
El ejemplo de DNI validator es perfectamente aplicable en Per√∫. Un DNI v√°lido tiene exactamente 8 d√≠gitos. La funci√≥n verifica primero si hay valor (para no validar campos vac√≠os), luego verifica la longitud. Simple, efectivo, reutilizable.
Podr√≠an expandir este validador. Verificar que sean solo n√∫meros con una expresi√≥n regular. Verificar el d√≠gito verificador si existiera. Incluso hacer una llamada a RENIEC para verificar que existe (eso ser√≠a validaci√≥n as√≠ncrona, que veremos pronto).
El objeto de error { invalidDni: true } es importante. El key 'invalidDni' es c√≥mo identificar√°n este error espec√≠fico en el template. Pueden agregar m√°s informaci√≥n: { invalidDni: { actualLength: dni.length, requiredLength: 8 } }.
Estos validadores son reutilizables. Def√≠nanlos en un archivo separado, exp√≥rtenlos, √∫senlos en m√∫ltiples formularios. Es como tener una biblioteca de reglas de negocio que pueden aplicar consistentemente.
La composici√≥n funciona igual que con validadores built-in: [Validators.required, dniValidator]. Angular ejecuta todos y acumula errores.
________________________________________
Diapositiva 16: Validadores con Par√°metros (4 minutos)
Los validadores parametrizables llevan la reutilizaci√≥n al siguiente nivel.
El patr√≥n Factory es brillante aqu√≠. En lugar de una funci√≥n validadora, tienen una funci√≥n que retorna una funci√≥n validadora. Es como tener un molde configurable que produce validadores espec√≠ficos.
El ejemplo forbiddenWords es inmediatamente √∫til. Imaginen un formulario de username donde quieren prohibir 'admin', 'root', 'test', 'temp'. En lugar de hardcodear estos valores, los pasan como par√°metro.
La funci√≥n externa recibe la configuraci√≥n (las palabras prohibidas). La funci√≥n interna es el validador real que recibe el control. Este patr√≥n de closure permite que el validador interno acceda a los par√°metros externos.
El uso de toLowerCase() es UX inteligente. No importa si el usuario escribe 'Admin', 'ADMIN', o 'admin', todos son detectados. Es validaci√≥n robusta que previene bypasses accidentales.
Retornar la palabra encontrada en el error ({ forbiddenWord: found }) permite mensajes espec√≠ficos. En lugar de "Username inv√°lido", pueden mostrar "La palabra 'admin' no est√° permitida en usernames".
Este patr√≥n es infinitamente flexible. Pueden crear validadores para rangos de fechas, validadores que comparan con listas din√°micas, validadores que aplican reglas de negocio complejas. La configuraci√≥n los hace reutilizables entre proyectos.
Un validador de rango podr√≠a ser: rangeValidator(min, max). Un validador de formato podr√≠a ser: formatValidator(regex, errorMessage). Las posibilidades son ilimitadas.
________________________________________
Diapositiva 17: Validaciones As√≠ncronas (5 minutos)
Las validaciones as√≠ncronas son donde sus formularios se vuelven verdaderamente inteligentes.
Los casos de uso son comunes y cr√≠ticos. Verificar si un email ya est√° registrado previene frustraciones en el registro. Verificar disponibilidad de username evita el ciclo de "intente otro nombre" m√∫ltiples veces. Validar c√≥digos con APIs externas asegura datos correctos desde el inicio.
La estructura es similar a validadores s√≠ncronos, pero retornan Observable o Promise en lugar de objeto directo. Angular se suscribe autom√°ticamente, muestra estado de "pending" mientras valida, y actualiza cuando completa.
El ejemplo emailAvailable es patr√≥n de producci√≥n. Hacen petici√≥n HTTP al backend, que verifica en base de datos si existe. El map transforma la respuesta booleana en ValidationErrors o null.
El estado pending es UX crucial. Mientras la validaci√≥n as√≠ncrona corre, el campo tiene estado 'PENDING'. Pueden mostrar un spinner, un mensaje "Verificando...", feedback visual que algo est√° pasando.
El timing importa. No quieren verificar disponibilidad en cada keystroke. Usen debounceTime en el Observable, o mejor a√∫n, validen en blur en lugar de cambio. Es balance entre feedback r√°pido y no sobrecargar el servidor.
El manejo de errores es cr√≠tico. Si la petici√≥n HTTP falla, ¬øqu√© hacen? ¬øMarcan el campo como v√°lido o inv√°lido? Generalmente, usen catchError para retornar null (v√°lido) y logeen el error. No castiguen al usuario por problemas de red.
Las validaciones as√≠ncronas son el tercer par√°metro en FormControl: ['', validadoresS√≠ncronos, validadoresAs√≠ncronos]. Pueden tener m√∫ltiples de cada tipo.
________________________________________
Diapositiva 18: Cross-field Validation (4 minutos)
La validaci√≥n entre campos es donde los formularios se vuelven verdaderamente sofisticados.
El ejemplo cl√°sico es confirmar contrase√±a, pero los casos reales son infinitos. Fecha de fin debe ser despu√©s de fecha de inicio. La suma de porcentajes debe ser 100%. El monto de descuento no puede exceder el total.
La clave es que estos validadores se aplican al FormGroup, no a FormControls individuales. Tiene sentido: est√°n validando la relaci√≥n entre campos, no campos aislados.
El validador passwordMatch es elegantemente simple. Obtiene ambos campos del FormGroup, compara valores, retorna error si no coinciden. El error est√° en el grupo, no en campos individuales.
Aplicar el validador al grupo requiere sintaxis especial: { validators: passwordMatch } como segundo par√°metro de .group(). No confundan con validadores de campos individuales.
El manejo de errores es diferente. El error est√° en form.errors, no en form.get('field').errors. En el template, pueden chequear userForm.errors?.['mismatch'] para mostrar mensajes.
Un patr√≥n √∫til es tambi√©n setear errores en campos individuales desde el validador de grupo. Esto permite mostrar errores junto a campos espec√≠ficos, no solo como error general del formulario.
La validaci√≥n condicional es poderosa aqu√≠. Si el usuario elige "proyecto con financiamiento", pueden validar que los campos de presupuesto sumen correctamente. Si elige "proyecto sin financiamiento", esas validaciones no aplican.
________________________________________
Diapositiva 19: Formularios Din√°micos (5 minutos)
FormArray es su herramienta para formularios que crecen y se adaptan seg√∫n las necesidades del usuario.
El concepto es simple pero poderoso: una lista de FormControls o FormGroups que puede crecer o reducirse din√°micamente. Es como tener un formulario el√°stico que se estira seg√∫n lo necesiten.
El ejemplo de tel√©fonos es universal. Un usuario puede tener uno, tres, diez tel√©fonos. No pueden predefinir cu√°ntos campos mostrar. FormArray resuelve esto elegantemente.
this.fb.array([]) crea un FormArray vac√≠o. Es como una lista esperando ser llenada. Pueden inicializarlo con valores si tienen datos existentes.
addPhone() muestra la adici√≥n din√°mica. push() agrega un nuevo FormControl al array. En el template, Angular autom√°ticamente renderiza el nuevo campo. Es reactividad en acci√≥n.
removePhone(index) demuestra remoci√≥n precisa. removeAt() elimina el control en esa posici√≥n. Los √≠ndices se reajustan autom√°ticamente. No hay huecos, no hay problemas de √≠ndices.
En el template, usan *ngFor="let phone of phones.controls; let i = index". Cada iteraci√≥n es un FormControl que pueden vincular con [formControl]="phone".
Los casos de uso son infinitos. Lista de educaci√≥n en un CV donde pueden agregar m√∫ltiples t√≠tulos. Items en una orden de compra. Participantes en un proyecto. Cualquier lista de datos similares.
Pueden tener FormArrays de FormGroups para estructuras complejas. Imaginen una lista de direcciones donde cada direcci√≥n tiene calle, ciudad, c√≥digo postal. Cada elemento del array es un FormGroup completo.
La validaci√≥n funciona normal. Pueden validar elementos individuales o el array completo. Por ejemplo, requerir al menos un tel√©fono, m√°ximo cinco, cada uno con formato v√°lido.
________________________________________
Diapositiva 20: Seguridad en Angular (4 minutos)
La seguridad no es opcional. Cada formulario es una puerta potencial para atacantes.
XSS (Cross-Site Scripting) es cuando c√≥digo malicioso se ejecuta en el navegador del usuario. Un atacante inyecta JavaScript en un campo, se guarda en la base de datos, y cuando otro usuario lo ve, el script se ejecuta robando cookies, tokens, datos sensibles.
Angular sanitiza autom√°ticamente, pero no sean complacientes. Eviten innerHTML directo, especialmente con contenido de usuarios. Si necesitan HTML din√°mico, usen DomSanitizer, pero entiendan los riesgos. Es como manejar qu√≠micos peligrosos: con el equipo adecuado y mucho cuidado.
CSRF (Cross-Site Request Forgery) es cuando un sitio malicioso hace requests a su aplicaci√≥n usando las credenciales del usuario. Como si alguien firmara documentos en su nombre sin su conocimiento.
Implementen tokens CSRF. Cada formulario incluye un token √∫nico que el servidor valida. Sin el token correcto, el request es rechazado. Es como un sello de autenticidad en documentos importantes.
Los Injection Attacks no son solo SQL. Pueden ser NoSQL, LDAP, comandos de sistema. La regla es simple: nunca conf√≠en en input de usuarios. Siempre saniticen, siempre validen, siempre usen consultas parametrizadas.
La validaci√≥n en el cliente no es seguridad. Es UX. Un atacante puede bypasser su validaci√≥n de JavaScript en segundos. Siempre validen en el servidor. El cliente valida por conveniencia, el servidor valida por seguridad.
El principio de menor privilegio aplica. Si un formulario solo necesita crear registros, no le den permisos de eliminar. Si un usuario solo puede editar sus propios datos, verifiquen ownership en el servidor.
________________________________________
Diapositiva 21: Performance - OnPush (4 minutos)
OnPush Change Detection es como pasar de revisar todo constantemente a revisar solo cuando hay notificaciones.
La estrategia Default de Angular es segura pero costosa. En cada ciclo de detecci√≥n, Angular revisa TODOS los componentes para ver si algo cambi√≥. Es como un guardia de seguridad que revisa cada oficina cada minuto, incluso las vac√≠as.
OnPush es inteligencia aplicada. El componente solo se revisa si: un @Input cambia referencia, un evento se dispara en el componente o sus hijos, o un Observable emite y el componente est√° suscrito con async pipe.
Para formularios, OnPush es especialmente poderoso. Los formularios tienden a ser islas de interactividad. Cuando el usuario escribe en un campo, solo ese formulario necesita actualizarse, no toda la aplicaci√≥n.
Implementarlo es trivial: changeDetection: ChangeDetectionStrategy.OnPush en el decorador. Pero las implicaciones son profundas. Deben pensar en inmutabilidad, en referencias, en c√≥mo fluyen los datos.
Con Reactive Forms y OnPush, tienen lo mejor de ambos mundos. Los FormControls emiten cambios, OnPush los detecta, solo ese componente se actualiza. Es eficiencia quir√∫rgica.
En aplicaciones grandes, la diferencia es dram√°tica. De cientos de chequeos por segundo a decenas. De lag perceptible a fluidez instant√°nea. Es la diferencia entre una aplicaci√≥n del 2015 y una del 2025.
El truco est√° en la inmutabilidad. Siempre creen nuevos objetos/arrays en lugar de mutar existentes. [...array, newItem] en lugar de array.push(newItem). OnPush detecta el cambio de referencia y actualiza.
________________________________________
Diapositiva 22: Lazy Loading (3 minutos)
Lazy Loading es como un buffet donde solo traen los platos cuando los piden, no todos de una vez.
Sin Lazy Loading, toda su aplicaci√≥n se carga al inicio. Cada m√≥dulo, cada componente, cada byte de JavaScript. Es como descargar una enciclopedia completa para leer un art√≠culo. El usuario espera, el navegador sufre, la experiencia es pobre.
Con Lazy Loading, solo cargan lo necesario inicialmente. El m√≥dulo de administraci√≥n se carga cuando navegan a /admin. El m√≥dulo de reportes cuando van a /reports. Es eficiencia bajo demanda.
La implementaci√≥n es sorprendentemente simple. En lugar de importar el m√≥dulo directamente, usan una funci√≥n que retorna una promesa del m√≥dulo. Angular se encarga del resto: carga, cach√©, integraci√≥n.
El impacto es inmediato y medible. Una aplicaci√≥n de 5MB puede tener un bundle inicial de 1.5MB con Lazy Loading. Es 70% menos tiempo de carga inicial. En conexiones m√≥viles, es la diferencia entre usuarios que esperan y usuarios que abandonan.
Para formularios, Lazy Loading es especialmente √∫til. Formularios complejos con validadores personalizados, componentes especializados, pueden estar en m√≥dulos separados. El formulario de registro empresarial de 50 campos no necesita cargarse para usuarios que solo hacen login.
La estrategia de preloading a√±ade inteligencia. Pueden precargar m√≥dulos en background despu√©s de que la aplicaci√≥n inicial carga. El usuario no espera, pero cuando navega, todo est√° listo instant√°neamente.
________________________________________
Diapositiva 23: Accesibilidad (a11y) (4 minutos)
La accesibilidad no es caridad; es profesionalismo. Sus formularios deben funcionar para todos.
Labels y ARIA son fundamentales. Cada input necesita un label asociado. No solo placeholder, un label real. Screen readers dependen de esto para describir campos a usuarios con discapacidad visual.
aria-label es para cuando no pueden tener un label visible. aria-describedby conecta campos con texto de ayuda o errores. aria-invalid indica estado de validaci√≥n. Es metadata que hace sus formularios hablables.
La navegaci√≥n por teclado debe ser impecable. Tab debe moverse l√≥gicamente entre campos. Enter debe submitir formularios. Escape debe cancelar modales. No todos usan mouse; muchos navegan exclusivamente con teclado.
Los screen readers necesitan informaci√≥n clara. Mensajes de error deben ser descriptivos: "El DNI debe contener 8 d√≠gitos" no "Campo inv√°lido". Usen role="alert" para mensajes importantes que deben ser anunciados inmediatamente.
El contraste es cr√≠tico. Texto gris claro en fondo blanco puede verse moderno, pero es ilegible para usuarios con baja visi√≥n. WCAG requiere ratio de 4.5:1 para texto normal, 3:1 para texto grande. Herramientas como Chrome DevTools pueden verificar esto.
Los targets de click de 44x44px no son capricho. Usuarios con problemas motores necesitan √°reas m√°s grandes. Ese checkbox tiny puede ser imposible de clickear para alguien con artritis o Parkinson.
La accesibilidad beneficia a todos. Formularios accesibles son m√°s usables para usuarios en m√≥viles, usuarios en ambientes ruidosos, usuarios cansados. Es dise√±o universal que mejora la experiencia para todos.
________________________________________
Diapositiva 24: Testing B√°sico (3 minutos)
Las pruebas son su red de seguridad. C√≥digo sin tests es como construcci√≥n sin planos: funciona hasta que no.
El patr√≥n AAA (Arrange-Act-Assert) es su mantra. Arrange prepara el escenario: crean el componente, configuran datos iniciales. Act ejecuta la acci√≥n: llaman el m√©todo, disparan el evento. Assert verifica el resultado: comprueban que el estado es el esperado.
El ejemplo muestra testing b√°sico pero esencial. Verifican que el formulario se crea con valores iniciales correctos. No es test complejo, pero detecta regresiones b√°sicas.
Para formularios, testen la creaci√≥n inicial, que validadores funcionan correctamente, que submit se deshabilita cuando es inv√°lido, que errores se muestran en condiciones correctas.
No necesitan 100% coverage. Testen lo cr√≠tico: validaci√≥n de datos sensibles, l√≥gica de negocio compleja, integraciones con servicios. Es mejor pocos tests bien escritos que muchos tests fr√°giles.
Los tests son documentaci√≥n ejecutable. Un nuevo desarrollador puede leer los tests y entender qu√© debe hacer el c√≥digo. Es conocimiento que no se desactualiza.
La confianza que dan los tests es invaluable. Pueden refactorizar sabiendo que si algo se rompe, los tests lo detectar√°n. Pueden agregar features sin miedo a romper existentes. Es libertad a trav√©s de la disciplina.
________________________________________
Diapositiva 25: Cierre y Q&A (5 minutos)
Felicitaciones. Han completado un viaje intensivo por el mundo profesional de formularios y mejores pr√°cticas en Angular.
Hoy dominaron ambos paradigmas de formularios. Template-driven ya no es "el simple", es el apropiado para casos espec√≠ficos. Reactive Forms no es "el complejo", es el poderoso para necesidades avanzadas. Tienen criterio para elegir.
Las validaciones que implementaron van desde b√°sicas hasta as√≠ncronas complejas. Pueden validar DNIs, verificar disponibilidad en tiempo real, asegurar consistencia entre campos. Sus formularios ahora piensan.
La seguridad que aplicaron protege a sus usuarios y su reputaci√≥n. XSS y CSRF no son solo acr√≥nimos; son amenazas reales que ahora saben prevenir. Cada formulario que construyan ser√° una fortaleza.
La performance con OnPush y Lazy Loading transforma aplicaciones lentas en experiencias fluidas. No es optimizaci√≥n prematura; es arquitectura inteligente desde el inicio.
La accesibilidad que implementaron abre sus aplicaciones a millones de usuarios adicionales. No es cumplimiento legal; es desarrollo √©tico y profesional.
Los tests b√°sicos que escribieron son el inicio de una pr√°ctica que definir√° su carrera. Desarrolladores que testean duermen tranquilos y entregan confiablemente.
La pr√≥xima sesi√≥n, el lunes 25 de agosto, exploraremos Angular Material UI. Con los formularios s√≥lidos de hoy, agregar una interfaz hermosa ser√° la cereza del pastel. Componentes profesionales, temas personalizados, experiencias que deleitan.
Practiquen lo aprendido. Tomen un formulario existente y m√≠guenlo a Reactive Forms. Agreguen validaciones personalizadas. Implementen OnPush. Cada mejora es aprendizaje consolidado.
¬°Excelente trabajo! Han elevado sus habilidades al nivel que la industria demanda. Nos vemos el lunes a las 19:00 para continuar construyendo excelencia.
¬°Hasta la pr√≥xima sesi√≥n! üöÄ

