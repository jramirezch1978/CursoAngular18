<!-- 
TEMPLATE HTML - FORMULARIO DE CONTACTO TEMPLATE-DRIVEN
======================================================

Este template demuestra todos los conceptos clave de Template-driven Forms:
- Binding bidireccional [(ngModel)]
- Referencias locales para acceder al estado
- Validaciones declarativas en HTML
- Manejo inteligente de errores basado en estados
- UX profesional con feedback visual

ESTRUCTURA:
1. Formulario principal con referencia local
2. Campos de entrada con validaciones
3. Manejo de errores especÃ­fico por campo
4. Botones de acciÃ³n con estados condicionales
5. InformaciÃ³n de debug (solo desarrollo)

PROVIAS DESCENTRALIZADO - Angular v18
Instructor: Ing. Jhonny Alexander Ramirez Chiroque
-->

<div class="form-container">
  <!-- ========== ENCABEZADO ========== -->
  <header class="form-header">
    <h2>ğŸ“ Formulario de Contacto</h2>
    <p class="subtitle">Template-driven Forms - Angular v18</p>
  </header>

  <!-- 
  FORMULARIO PRINCIPAL 
  ====================
  
  Elementos clave:
  - #contactForm="ngForm": Referencia local que nos da acceso al estado del formulario
  - (ngSubmit): Event binding que se ejecuta cuando se envÃ­a el formulario
  - novalidate: Desactiva validaciones HTML5 nativas (usamos las de Angular)
  
  ESTADOS DISPONIBLES en contactForm:
  - .valid/.invalid: Â¿Todos los campos son vÃ¡lidos?
  - .pristine/.dirty: Â¿El usuario modificÃ³ algÃºn campo?
  - .touched/.untouched: Â¿El usuario interactuÃ³ con algÃºn campo?
  - .pending: Â¿Hay validaciones asÃ­ncronas ejecutÃ¡ndose?
  - .submitted: Â¿Se intentÃ³ enviar el formulario?
  -->
  <form #contactForm="ngForm" (ngSubmit)="onSubmit()" novalidate class="contact-form">
    
    <!-- ========== CAMPO NOMBRE ========== -->
    <div class="form-group">
      <label for="name" class="form-label">
        Nombre Completo 
        <span class="required-asterisk">*</span>
      </label>
      
      <!--
      INPUT DE NOMBRE - CONCEPTOS DEMOSTRADOS:
      
      1. [(ngModel)]="model.name" - BINDING BIDIRECCIONAL
         - [ngModel]: modelo â†’ vista (cuando model.name cambia, se actualiza el input)
         - (ngModelChange): vista â†’ modelo (cuando el usuario escribe, se actualiza model.name)
         - [(ngModel)]: ambas direcciones simultÃ¡neamente
      
      2. name="name" - CRÃTICO Y OBLIGATORIO
         - Angular usa este nombre para registrar el control en el FormGroup interno
         - Sin name, el campo no se incluye en la validaciÃ³n del formulario
         - Debe ser Ãºnico dentro del formulario
      
      3. #nameInput="ngModel" - REFERENCIA LOCAL
         - Nos da acceso directo al estado de este campo especÃ­fico
         - Podemos usar nameInput.valid, nameInput.errors, nameInput.touched, etc.
         - Ãštil para mostrar errores especÃ­ficos de este campo
      
      4. VALIDACIONES DECLARATIVAS:
         - required: Campo obligatorio (HTML5 + Angular)
         - minlength="3": MÃ­nimo 3 caracteres
         - maxlength="50": MÃ¡ximo 50 caracteres
         - pattern: TambiÃ©n podrÃ­amos agregar regex para formato especÃ­fico
      
      5. CLASES CSS DINÃMICAS:
         - [class.is-invalid]: Agrega clase 'is-invalid' cuando nameInput.invalid && nameInput.touched
         - Las clases ng-* se agregan automÃ¡ticamente por Angular:
           * ng-valid/ng-invalid
           * ng-pristine/ng-dirty  
           * ng-touched/ng-untouched
      -->
      <input 
        type="text" 
        id="name"
        name="name"
        [(ngModel)]="model.name"
        #nameInput="ngModel"
        required
        minlength="3"
        maxlength="50"
        class="form-control"
        [class.is-invalid]="nameInput.invalid && nameInput.touched"
        [class.is-valid]="nameInput.valid && nameInput.touched"
        placeholder="Ingrese su nombre completo"
        autocomplete="name">
      
      <!--
      MANEJO INTELIGENTE DE ERRORES
      =============================
      
      PATRÃ“N CLAVE: Solo mostrar errores DESPUÃ‰S de interacciÃ³n (touched)
      
      âŒ MAL: *ngIf="nameInput.invalid" 
         MostrarÃ­a errores apenas carga la pÃ¡gina
      
      âœ… BIEN: *ngIf="nameInput.invalid && nameInput.touched"
         Solo muestra errores despuÃ©s de que el usuario interactuÃ³
      
      TIPOS DE ERROR A MANEJAR:
      - required: Campo vacÃ­o
      - minlength: Muy pocos caracteres  
      - maxlength: Demasiados caracteres
      - pattern: No cumple formato esperado
      
      ACCESO A INFORMACIÃ“N DE ERROR:
      - nameInput.errors?.['required']: Â¿Falta el campo?
      - nameInput.errors?.['minlength']: Â¿Muy corto? (incluye longitud actual y requerida)
      - nameInput.errors?.['maxlength']: Â¿Muy largo?
      -->
      <div *ngIf="nameInput.invalid && nameInput.touched" class="error-messages">
        <div *ngIf="nameInput.errors?.['required']" class="error-message">
          <i class="error-icon">âš ï¸</i>
          El nombre es obligatorio
        </div>
        <div *ngIf="nameInput.errors?.['minlength']" class="error-message">
          <i class="error-icon">ğŸ“</i>
          MÃ­nimo {{ nameInput.errors?.['minlength'].requiredLength }} caracteres
          (actualmente {{ nameInput.errors?.['minlength'].actualLength }})
        </div>
        <div *ngIf="nameInput.errors?.['maxlength']" class="error-message">
          <i class="error-icon">ğŸ“</i>
          MÃ¡ximo {{ nameInput.errors?.['maxlength'].requiredLength }} caracteres
        </div>
      </div>
    </div>

    <!-- ========== CAMPO EMAIL ========== -->
    <div class="form-group">
      <label for="email" class="form-label">
        Email Corporativo 
        <span class="required-asterisk">*</span>
      </label>
      
      <!--
      INPUT DE EMAIL - VALIDACIONES AVANZADAS:
      
      1. type="email" - ValidaciÃ³n HTML5 bÃ¡sica de formato email
      2. email - Directiva Angular que mejora la validaciÃ³n HTML5
      3. pattern="[a-z0-9._%+-]+@provias\.gob\.pe" - REGEX ESPECÃFICA
         - Solo permite emails @provias.gob.pe
         - Escapa el punto con \. para que sea literal
         - Permite caracteres comunes en emails antes del @
      
      NOTA EDUCATIVA sobre PATTERN:
      - [a-z0-9._%+-]+ : Uno o mÃ¡s caracteres alfanumÃ©ricos, punto, guiÃ³n bajo, %, +, -
      - @ : CarÃ¡cter @ literal
      - provias\.gob\.pe : Dominio especÃ­fico (puntos escapados)
      -->
      <input 
        type="email" 
        id="email"
        name="email"
        [(ngModel)]="model.email"
        #emailInput="ngModel"
        required
        email
        pattern="[a-z0-9._%+-]+@provias\.gob\.pe"
        class="form-control"
        [class.is-invalid]="emailInput.invalid && emailInput.touched"
        [class.is-valid]="emailInput.valid && emailInput.touched"
        placeholder="nombre@provias.gob.pe"
        autocomplete="email">
      
      <!-- Errores especÃ­ficos de email -->
      <div *ngIf="emailInput.invalid && emailInput.touched" class="error-messages">
        <div *ngIf="emailInput.errors?.['required']" class="error-message">
          <i class="error-icon">ğŸ“§</i>
          El email es obligatorio
        </div>
        <div *ngIf="emailInput.errors?.['email']" class="error-message">
          <i class="error-icon">ğŸ“§</i>
          Formato de email invÃ¡lido
        </div>
        <div *ngIf="emailInput.errors?.['pattern']" class="error-message">
          <i class="error-icon">ğŸ¢</i>
          Debe ser un email corporativo @provias.gob.pe
        </div>
      </div>
    </div>

    <!-- ========== CAMPO TELÃ‰FONO (OPCIONAL) ========== -->
    <div class="form-group">
      <label for="phone" class="form-label">
        TelÃ©fono
        <span class="optional-text">(opcional)</span>
      </label>
      
      <!--
      CAMPO OPCIONAL - SIN REQUIRED:
      - No tiene validaciÃ³n required
      - AÃºn asÃ­ puede tener otras validaciones (pattern, minlength, etc.)
      - El formulario serÃ¡ vÃ¡lido sin este campo
      - Ãštil para informaciÃ³n adicional no crÃ­tica
      -->
      <input 
        type="tel" 
        id="phone"
        name="phone"
        [(ngModel)]="model.phone"
        #phoneInput="ngModel"
        pattern="(\+51)?[0-9]{9}"
        class="form-control"
        [class.is-invalid]="phoneInput.invalid && phoneInput.touched"
        [class.is-valid]="phoneInput.valid && phoneInput.touched"
        placeholder="+51987654321 o 987654321"
        autocomplete="tel">
      
      <!-- Solo mostramos error si hay contenido y es invÃ¡lido -->
      <div *ngIf="phoneInput.invalid && phoneInput.touched && phoneInput.value" class="error-messages">
        <div *ngIf="phoneInput.errors?.['pattern']" class="error-message">
          <i class="error-icon">ğŸ“±</i>
          Formato: +51987654321 o 987654321 (9 dÃ­gitos)
        </div>
      </div>
    </div>

    <!-- ========== SELECT DE DEPARTAMENTO ========== -->
    <div class="form-group">
      <label for="department" class="form-label">
        Departamento 
        <span class="required-asterisk">*</span>
      </label>
      
      <!--
      SELECT DINÃMICO - CONCEPTOS:
      
      1. Opciones pobladas desde API (departments array)
      2. *ngFor para iterar sobre las opciones
      3. [value] para el valor que se asigna al modelo
      4. Primera opciÃ³n vacÃ­a para forzar selecciÃ³n consciente
      5. Binding bidireccional igual que inputs
      
      PATRÃ“N COMÃšN: Cargar opciones en ngOnInit desde un servicio
      -->
      <select 
        id="department"
        name="department"
        [(ngModel)]="model.department"
        #departmentInput="ngModel"
        required
        class="form-control form-select"
        [class.is-invalid]="departmentInput.invalid && departmentInput.touched">
        
        <!-- OpciÃ³n vacÃ­a por defecto -->
        <option value="" disabled>Seleccione un departamento</option>
        
        <!-- Opciones dinÃ¡micas desde API -->
        <option 
          *ngFor="let dept of departments" 
          [value]="dept.name">
          {{ dept.name }} ({{ dept.code }})
        </option>
      </select>
      
      <div *ngIf="departmentInput.invalid && departmentInput.touched" class="error-messages">
        <div *ngIf="departmentInput.errors?.['required']" class="error-message">
          <i class="error-icon">ğŸ¢</i>
          Debe seleccionar un departamento
        </div>
      </div>
    </div>

    <!-- ========== RADIO BUTTONS PARA PRIORIDAD ========== -->
    <div class="form-group">
      <fieldset class="form-fieldset">
        <legend class="form-label">
          Prioridad 
          <span class="required-asterisk">*</span>
        </legend>
        
        <!--
        RADIO BUTTONS - CONCEPTOS:
        
        1. Todos los radios del grupo tienen el mismo name="priority"
        2. Cada radio tiene un value diferente
        3. [(ngModel)] se conecta con el modelo una sola vez por grupo
        4. Solo uno puede estar seleccionado a la vez
        5. Para validaciÃ³n, podemos referenciar cualquier radio del grupo
        
        ACCESIBILIDAD:
        - fieldset agrupa los radios semÃ¡nticamente
        - legend describe el grupo
        - labels conectados con for/id
        -->
        <div class="radio-group">
          <div class="radio-item">
            <input 
              type="radio" 
              id="priority-low"
              name="priority"
              value="low"
              [(ngModel)]="model.priority"
              #priorityInput="ngModel"
              required>
            <label for="priority-low">ğŸŸ¢ Baja</label>
          </div>
          
          <div class="radio-item">
            <input 
              type="radio" 
              id="priority-medium"
              name="priority"
              value="medium"
              [(ngModel)]="model.priority">
            <label for="priority-medium">ğŸŸ¡ Media</label>
          </div>
          
          <div class="radio-item">
            <input 
              type="radio" 
              id="priority-high"
              name="priority"
              value="high"
              [(ngModel)]="model.priority">
            <label for="priority-high">ğŸ”´ Alta</label>
          </div>
        </div>
        
        <div *ngIf="priorityInput.invalid && priorityInput.touched" class="error-messages">
          <div *ngIf="priorityInput.errors?.['required']" class="error-message">
            <i class="error-icon">âš¡</i>
            Debe seleccionar una prioridad
          </div>
        </div>
      </fieldset>
    </div>

    <!-- ========== TEXTAREA PARA MENSAJE ========== -->
    <div class="form-group">
      <label for="message" class="form-label">
        Mensaje 
        <span class="required-asterisk">*</span>
        <span class="char-counter">({{ getRemainingChars() }} caracteres restantes)</span>
      </label>
      
      <!--
      TEXTAREA - CAMPO DE TEXTO LARGO:
      
      1. Similar a input pero para texto multilÃ­nea
      2. rows: altura inicial en lÃ­neas de texto
      3. maxlength: lÃ­mite de caracteres (tambiÃ©n en validaciÃ³n)
      4. resize: vertical permite cambiar altura
      -->
      <textarea 
        id="message"
        name="message"
        [(ngModel)]="model.message"
        #messageInput="ngModel"
        required
        minlength="10"
        maxlength="500"
        rows="4"
        class="form-control form-textarea"
        [class.is-invalid]="messageInput.invalid && messageInput.touched"
        [class.is-valid]="messageInput.valid && messageInput.touched"
        placeholder="Describa su consulta o mensaje..."></textarea>
      
      <div *ngIf="messageInput.invalid && messageInput.touched" class="error-messages">
        <div *ngIf="messageInput.errors?.['required']" class="error-message">
          <i class="error-icon">ğŸ’¬</i>
          El mensaje es obligatorio
        </div>
        <div *ngIf="messageInput.errors?.['minlength']" class="error-message">
          <i class="error-icon">ğŸ“</i>
          MÃ­nimo {{ messageInput.errors?.['minlength'].requiredLength }} caracteres
        </div>
        <div *ngIf="messageInput.errors?.['maxlength']" class="error-message">
          <i class="error-icon">ğŸ“</i>
          MÃ¡ximo {{ messageInput.errors?.['maxlength'].requiredLength }} caracteres
        </div>
      </div>
    </div>

    <!-- ========== CHECKBOX TÃ‰RMINOS Y CONDICIONES ========== -->
    <div class="form-group">
      <!--
      CHECKBOX - VALIDACIÃ“N BOOLEAN:
      
      1. type="checkbox" para valores true/false
      2. required hace que DEBE ser true (checked) para ser vÃ¡lido
      3. PatrÃ³n comÃºn para aceptaciÃ³n de tÃ©rminos
      4. Label clickeable mejora la UX
      -->
      <div class="checkbox-group">
        <input 
          type="checkbox"
          id="acceptTerms"
          name="acceptTerms"
          [(ngModel)]="model.acceptTerms"
          #termsInput="ngModel"
          required>
        <label for="acceptTerms" class="checkbox-label">
          <span class="checkbox-text">
            Acepto los 
            <a href="#" target="_blank" class="terms-link">tÃ©rminos y condiciones</a>
            <span class="required-asterisk">*</span>
          </span>
        </label>
      </div>
      
      <div *ngIf="termsInput.invalid && termsInput.touched" class="error-messages">
        <div *ngIf="termsInput.errors?.['required']" class="error-message">
          <i class="error-icon">ğŸ“‹</i>
          Debe aceptar los tÃ©rminos y condiciones
        </div>
      </div>
    </div>

    <!-- ========== BOTONES DE ACCIÃ“N ========== -->
    <div class="form-actions">
      <!--
      BOTÃ“N LIMPIAR - RESET:
      
      1. type="button" (no submit)
      2. Llama mÃ©todo resetForm() pasando referencia del formulario
      3. Esto resetea tanto los datos como los estados de validaciÃ³n
      -->
      <button 
        type="button" 
        class="btn btn-secondary"
        (click)="resetForm(contactForm)"
        [disabled]="loading">
        <i class="btn-icon">ğŸ”„</i>
        Limpiar
      </button>
      
      <!--
      BOTÃ“N ENVIAR - SUBMIT:
      
      1. type="submit" ejecuta (ngSubmit) del form
      2. [disabled] con LÃ“GICA MÃšLTIPLE:
         - contactForm.invalid: Formulario tiene errores
         - loading: Enviando actualmente (evita doble envÃ­o)
      3. Contenido dinÃ¡mico segÃºn estado de loading
      4. Solo se puede clickear cuando TODO estÃ© vÃ¡lido
      
      UX INTELIGENTE:
      - Deshabilitado hasta que todo sea vÃ¡lido
      - Muestra loading durante envÃ­o
      - Previene mÃºltiples envÃ­os
      -->
      <button 
        type="submit" 
        class="btn btn-primary"
        [disabled]="contactForm.invalid || loading">
        
        <!-- Contenido condicional segÃºn estado loading -->
        <span *ngIf="!loading">
          <i class="btn-icon">ğŸ“¤</i>
          Enviar Contacto
        </span>
        <span *ngIf="loading">
          <i class="btn-icon loading">â³</i>
          Enviando...
        </span>
      </button>
    </div>

    <!-- ========== MENSAJE DE ESTADO ========== -->
    <!--
    FEEDBACK AL USUARIO:
    
    Muestra mensajes de Ã©xito o error despuÃ©s de intentar enviar.
    Clases CSS diferentes para Ã©xito vs error.
    -->
    <div *ngIf="statusMessage" 
         class="status-message"
         [class.success]="statusMessage.includes('âœ…')"
         [class.error]="statusMessage.includes('âŒ')">
      {{ statusMessage }}
    </div>
  </form>

  <!-- ========== INFORMACIÃ“N DE DEBUG (SOLO DESARROLLO) ========== -->
  <!--
  HERRAMIENTA EDUCATIVA:
  
  Esta secciÃ³n ayuda a los estudiantes a entender:
  - Estados del formulario en tiempo real
  - Valores del modelo
  - Estados de validaciÃ³n por campo
  
  â— IMPORTANTE: Remover en producciÃ³n
  -->
  <div *ngIf="showDebug" class="debug-panel">
    <div class="debug-header">
      <h4>ğŸ› Debug Info (Solo Desarrollo)</h4>
      <button (click)="toggleDebug()" class="debug-toggle">âŒ</button>
    </div>
    
    <div class="debug-content">
      <!-- Estados del formulario -->
      <div class="debug-section">
        <h5>ğŸ“Š Estados del Formulario</h5>
        <ul class="debug-list">
          <li>Valid: <span [class]="contactForm.valid ? 'valid' : 'invalid'">{{ contactForm.valid }}</span></li>
          <li>Dirty: <span [class]="contactForm.dirty ? 'dirty' : 'pristine'">{{ contactForm.dirty }}</span></li>
          <li>Touched: <span [class]="contactForm.touched ? 'touched' : 'untouched'">{{ contactForm.touched }}</span></li>
          <li>Submitted: <span>{{ contactForm.submitted }}</span></li>
        </ul>
      </div>
      
      <!-- Valores del modelo -->
      <div class="debug-section">
        <h5>ğŸ“‹ Valores del Modelo</h5>
        <pre class="debug-json">{{ model | json }}</pre>
      </div>
      
      <!-- Estados por campo -->
      <div class="debug-section">
        <h5>ğŸ” Estados por Campo</h5>
        <div class="debug-fields">
          <div class="debug-field">
            <strong>Nombre:</strong> 
            V:{{ nameInput.valid }} | 
            T:{{ nameInput.touched }} | 
            D:{{ nameInput.dirty }}
          </div>
          <div class="debug-field">
            <strong>Email:</strong> 
            V:{{ emailInput.valid }} | 
            T:{{ emailInput.touched }} | 
            D:{{ emailInput.dirty }}
          </div>
          <!-- Agregar mÃ¡s campos segÃºn sea necesario -->
        </div>
      </div>
    </div>
  </div>
</div>

<!--
SIGUIENTES PASOS PARA LOS ESTUDIANTES:
=====================================

Una vez que entiendan este template, pueden:

1. ğŸ¨ MEJORAR ESTILOS:
   - Agregar transiciones CSS
   - Mejorar responsive design  
   - Agregar iconos mÃ¡s atractivos

2. ğŸ“ MÃS VALIDACIONES:
   - ValidaciÃ³n de RUC/DNI peruano
   - ValidaciÃ³n asÃ­ncrona de email Ãºnico
   - Validaciones cruzadas entre campos

3. ğŸ”§ FUNCIONALIDADES:
   - Autoguardado en localStorage
   - Upload de archivos adjuntos
   - Captcha para seguridad

4. ğŸ§ª TESTING:
   - Unit tests para validaciones
   - Integration tests para envÃ­o
   - E2E tests para flujo completo

5. ğŸš€ MIGRACIÃ“N A REACTIVE FORMS:
   - Para mayor control programÃ¡tico
   - Validaciones mÃ¡s complejas
   - Better testing capabilities
-->
