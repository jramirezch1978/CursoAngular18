<!-- 
TEMPLATE HTML - FORMULARIO DE CONTACTO TEMPLATE-DRIVEN
======================================================

Este template demuestra todos los conceptos clave de Template-driven Forms:
- Binding bidireccional [(ngModel)]
- Referencias locales para acceder al estado
- Validaciones declarativas en HTML
- Manejo inteligente de errores basado en estados
- UX profesional con feedback visual

ESTRUCTURA:
1. Formulario principal con referencia local
2. Campos de entrada con validaciones
3. Manejo de errores específico por campo
4. Botones de acción con estados condicionales
5. Información de debug (solo desarrollo)

PROVIAS DESCENTRALIZADO - Angular v18
Instructor: Ing. Jhonny Alexander Ramirez Chiroque
-->

<div class="form-container">
  <!-- ========== ENCABEZADO ========== -->
  <header class="form-header">
    <h2>📝 Formulario de Contacto</h2>
    <p class="subtitle">Template-driven Forms - Angular v18</p>
  </header>

  <!-- 
  FORMULARIO PRINCIPAL 
  ====================
  
  Elementos clave:
  - #contactForm="ngForm": Referencia local que nos da acceso al estado del formulario
  - (ngSubmit): Event binding que se ejecuta cuando se envía el formulario
  - novalidate: Desactiva validaciones HTML5 nativas (usamos las de Angular)
  
  ESTADOS DISPONIBLES en contactForm:
  - .valid/.invalid: ¿Todos los campos son válidos?
  - .pristine/.dirty: ¿El usuario modificó algún campo?
  - .touched/.untouched: ¿El usuario interactuó con algún campo?
  - .pending: ¿Hay validaciones asíncronas ejecutándose?
  - .submitted: ¿Se intentó enviar el formulario?
  -->
  <form #contactForm="ngForm" (ngSubmit)="onSubmit()" novalidate class="contact-form">
    
    <!-- ========== CAMPO NOMBRE ========== -->
    <div class="form-group">
      <label for="name" class="form-label">
        Nombre Completo 
        <span class="required-asterisk">*</span>
      </label>
      
      <!--
      INPUT DE NOMBRE - CONCEPTOS DEMOSTRADOS:
      
      1. [(ngModel)]="model.name" - BINDING BIDIRECCIONAL
         - [ngModel]: modelo → vista (cuando model.name cambia, se actualiza el input)
         - (ngModelChange): vista → modelo (cuando el usuario escribe, se actualiza model.name)
         - [(ngModel)]: ambas direcciones simultáneamente
      
      2. name="name" - CRÍTICO Y OBLIGATORIO
         - Angular usa este nombre para registrar el control en el FormGroup interno
         - Sin name, el campo no se incluye en la validación del formulario
         - Debe ser único dentro del formulario
      
      3. #nameInput="ngModel" - REFERENCIA LOCAL
         - Nos da acceso directo al estado de este campo específico
         - Podemos usar nameInput.valid, nameInput.errors, nameInput.touched, etc.
         - Útil para mostrar errores específicos de este campo
      
      4. VALIDACIONES DECLARATIVAS:
         - required: Campo obligatorio (HTML5 + Angular)
         - minlength="3": Mínimo 3 caracteres
         - maxlength="50": Máximo 50 caracteres
         - pattern: También podríamos agregar regex para formato específico
      
      5. CLASES CSS DINÁMICAS:
         - [class.is-invalid]: Agrega clase 'is-invalid' cuando nameInput.invalid && nameInput.touched
         - Las clases ng-* se agregan automáticamente por Angular:
           * ng-valid/ng-invalid
           * ng-pristine/ng-dirty  
           * ng-touched/ng-untouched
      -->
      <input 
        type="text" 
        id="name"
        name="name"
        [(ngModel)]="model.name"
        #nameInput="ngModel"
        required
        minlength="3"
        maxlength="50"
        class="form-control"
        [class.is-invalid]="nameInput.invalid && nameInput.touched"
        [class.is-valid]="nameInput.valid && nameInput.touched"
        placeholder="Ingrese su nombre completo"
        autocomplete="name">
      
      <!--
      MANEJO INTELIGENTE DE ERRORES
      =============================
      
      PATRÓN CLAVE: Solo mostrar errores DESPUÉS de interacción (touched)
      
      ❌ MAL: *ngIf="nameInput.invalid" 
         Mostraría errores apenas carga la página
      
      ✅ BIEN: *ngIf="nameInput.invalid && nameInput.touched"
         Solo muestra errores después de que el usuario interactuó
      
      TIPOS DE ERROR A MANEJAR:
      - required: Campo vacío
      - minlength: Muy pocos caracteres  
      - maxlength: Demasiados caracteres
      - pattern: No cumple formato esperado
      
      ACCESO A INFORMACIÓN DE ERROR:
      - nameInput.errors?.['required']: ¿Falta el campo?
      - nameInput.errors?.['minlength']: ¿Muy corto? (incluye longitud actual y requerida)
      - nameInput.errors?.['maxlength']: ¿Muy largo?
      -->
      <div *ngIf="nameInput.invalid && nameInput.touched" class="error-messages">
        <div *ngIf="nameInput.errors?.['required']" class="error-message">
          <i class="error-icon">⚠️</i>
          El nombre es obligatorio
        </div>
        <div *ngIf="nameInput.errors?.['minlength']" class="error-message">
          <i class="error-icon">📏</i>
          Mínimo {{ nameInput.errors?.['minlength'].requiredLength }} caracteres
          (actualmente {{ nameInput.errors?.['minlength'].actualLength }})
        </div>
        <div *ngIf="nameInput.errors?.['maxlength']" class="error-message">
          <i class="error-icon">📏</i>
          Máximo {{ nameInput.errors?.['maxlength'].requiredLength }} caracteres
        </div>
      </div>
    </div>

    <!-- ========== CAMPO EMAIL ========== -->
    <div class="form-group">
      <label for="email" class="form-label">
        Email Corporativo 
        <span class="required-asterisk">*</span>
      </label>
      
      <!--
      INPUT DE EMAIL - VALIDACIONES AVANZADAS:
      
      1. type="email" - Validación HTML5 básica de formato email
      2. email - Directiva Angular que mejora la validación HTML5
      3. pattern="[a-z0-9._%+-]+@provias\.gob\.pe" - REGEX ESPECÍFICA
         - Solo permite emails @provias.gob.pe
         - Escapa el punto con \. para que sea literal
         - Permite caracteres comunes en emails antes del @
      
      NOTA EDUCATIVA sobre PATTERN:
      - [a-z0-9._%+-]+ : Uno o más caracteres alfanuméricos, punto, guión bajo, %, +, -
      - @ : Carácter @ literal
      - provias\.gob\.pe : Dominio específico (puntos escapados)
      -->
      <input 
        type="email" 
        id="email"
        name="email"
        [(ngModel)]="model.email"
        #emailInput="ngModel"
        required
        email
        pattern="[a-z0-9._%+-]+@provias\.gob\.pe"
        class="form-control"
        [class.is-invalid]="emailInput.invalid && emailInput.touched"
        [class.is-valid]="emailInput.valid && emailInput.touched"
        placeholder="nombre@provias.gob.pe"
        autocomplete="email">
      
      <!-- Errores específicos de email -->
      <div *ngIf="emailInput.invalid && emailInput.touched" class="error-messages">
        <div *ngIf="emailInput.errors?.['required']" class="error-message">
          <i class="error-icon">📧</i>
          El email es obligatorio
        </div>
        <div *ngIf="emailInput.errors?.['email']" class="error-message">
          <i class="error-icon">📧</i>
          Formato de email inválido
        </div>
        <div *ngIf="emailInput.errors?.['pattern']" class="error-message">
          <i class="error-icon">🏢</i>
          Debe ser un email corporativo @provias.gob.pe
        </div>
      </div>
    </div>

    <!-- ========== CAMPO TELÉFONO (OPCIONAL) ========== -->
    <div class="form-group">
      <label for="phone" class="form-label">
        Teléfono
        <span class="optional-text">(opcional)</span>
      </label>
      
      <!--
      CAMPO OPCIONAL - SIN REQUIRED:
      - No tiene validación required
      - Aún así puede tener otras validaciones (pattern, minlength, etc.)
      - El formulario será válido sin este campo
      - Útil para información adicional no crítica
      -->
      <input 
        type="tel" 
        id="phone"
        name="phone"
        [(ngModel)]="model.phone"
        #phoneInput="ngModel"
        pattern="(\+51)?[0-9]{9}"
        class="form-control"
        [class.is-invalid]="phoneInput.invalid && phoneInput.touched"
        [class.is-valid]="phoneInput.valid && phoneInput.touched"
        placeholder="+51987654321 o 987654321"
        autocomplete="tel">
      
      <!-- Solo mostramos error si hay contenido y es inválido -->
      <div *ngIf="phoneInput.invalid && phoneInput.touched && phoneInput.value" class="error-messages">
        <div *ngIf="phoneInput.errors?.['pattern']" class="error-message">
          <i class="error-icon">📱</i>
          Formato: +51987654321 o 987654321 (9 dígitos)
        </div>
      </div>
    </div>

    <!-- ========== SELECT DE DEPARTAMENTO ========== -->
    <div class="form-group">
      <label for="department" class="form-label">
        Departamento 
        <span class="required-asterisk">*</span>
      </label>
      
      <!--
      SELECT DINÁMICO - CONCEPTOS:
      
      1. Opciones pobladas desde API (departments array)
      2. *ngFor para iterar sobre las opciones
      3. [value] para el valor que se asigna al modelo
      4. Primera opción vacía para forzar selección consciente
      5. Binding bidireccional igual que inputs
      
      PATRÓN COMÚN: Cargar opciones en ngOnInit desde un servicio
      -->
      <select 
        id="department"
        name="department"
        [(ngModel)]="model.department"
        #departmentInput="ngModel"
        required
        class="form-control form-select"
        [class.is-invalid]="departmentInput.invalid && departmentInput.touched">
        
        <!-- Opción vacía por defecto -->
        <option value="" disabled>Seleccione un departamento</option>
        
        <!-- Opciones dinámicas desde API -->
        <option 
          *ngFor="let dept of departments" 
          [value]="dept.name">
          {{ dept.name }} ({{ dept.code }})
        </option>
      </select>
      
      <div *ngIf="departmentInput.invalid && departmentInput.touched" class="error-messages">
        <div *ngIf="departmentInput.errors?.['required']" class="error-message">
          <i class="error-icon">🏢</i>
          Debe seleccionar un departamento
        </div>
      </div>
    </div>

    <!-- ========== RADIO BUTTONS PARA PRIORIDAD ========== -->
    <div class="form-group">
      <fieldset class="form-fieldset">
        <legend class="form-label">
          Prioridad 
          <span class="required-asterisk">*</span>
        </legend>
        
        <!--
        RADIO BUTTONS - CONCEPTOS:
        
        1. Todos los radios del grupo tienen el mismo name="priority"
        2. Cada radio tiene un value diferente
        3. [(ngModel)] se conecta con el modelo una sola vez por grupo
        4. Solo uno puede estar seleccionado a la vez
        5. Para validación, podemos referenciar cualquier radio del grupo
        
        ACCESIBILIDAD:
        - fieldset agrupa los radios semánticamente
        - legend describe el grupo
        - labels conectados con for/id
        -->
        <div class="radio-group">
          <div class="radio-item">
            <input 
              type="radio" 
              id="priority-low"
              name="priority"
              value="low"
              [(ngModel)]="model.priority"
              #priorityInput="ngModel"
              required>
            <label for="priority-low">🟢 Baja</label>
          </div>
          
          <div class="radio-item">
            <input 
              type="radio" 
              id="priority-medium"
              name="priority"
              value="medium"
              [(ngModel)]="model.priority">
            <label for="priority-medium">🟡 Media</label>
          </div>
          
          <div class="radio-item">
            <input 
              type="radio" 
              id="priority-high"
              name="priority"
              value="high"
              [(ngModel)]="model.priority">
            <label for="priority-high">🔴 Alta</label>
          </div>
        </div>
        
        <div *ngIf="priorityInput.invalid && priorityInput.touched" class="error-messages">
          <div *ngIf="priorityInput.errors?.['required']" class="error-message">
            <i class="error-icon">⚡</i>
            Debe seleccionar una prioridad
          </div>
        </div>
      </fieldset>
    </div>

    <!-- ========== TEXTAREA PARA MENSAJE ========== -->
    <div class="form-group">
      <label for="message" class="form-label">
        Mensaje 
        <span class="required-asterisk">*</span>
        <span class="char-counter">({{ getRemainingChars() }} caracteres restantes)</span>
      </label>
      
      <!--
      TEXTAREA - CAMPO DE TEXTO LARGO:
      
      1. Similar a input pero para texto multilínea
      2. rows: altura inicial en líneas de texto
      3. maxlength: límite de caracteres (también en validación)
      4. resize: vertical permite cambiar altura
      -->
      <textarea 
        id="message"
        name="message"
        [(ngModel)]="model.message"
        #messageInput="ngModel"
        required
        minlength="10"
        maxlength="500"
        rows="4"
        class="form-control form-textarea"
        [class.is-invalid]="messageInput.invalid && messageInput.touched"
        [class.is-valid]="messageInput.valid && messageInput.touched"
        placeholder="Describa su consulta o mensaje..."></textarea>
      
      <div *ngIf="messageInput.invalid && messageInput.touched" class="error-messages">
        <div *ngIf="messageInput.errors?.['required']" class="error-message">
          <i class="error-icon">💬</i>
          El mensaje es obligatorio
        </div>
        <div *ngIf="messageInput.errors?.['minlength']" class="error-message">
          <i class="error-icon">📝</i>
          Mínimo {{ messageInput.errors?.['minlength'].requiredLength }} caracteres
        </div>
        <div *ngIf="messageInput.errors?.['maxlength']" class="error-message">
          <i class="error-icon">📝</i>
          Máximo {{ messageInput.errors?.['maxlength'].requiredLength }} caracteres
        </div>
      </div>
    </div>

    <!-- ========== CHECKBOX TÉRMINOS Y CONDICIONES ========== -->
    <div class="form-group">
      <!--
      CHECKBOX - VALIDACIÓN BOOLEAN:
      
      1. type="checkbox" para valores true/false
      2. required hace que DEBE ser true (checked) para ser válido
      3. Patrón común para aceptación de términos
      4. Label clickeable mejora la UX
      -->
      <div class="checkbox-group">
        <input 
          type="checkbox"
          id="acceptTerms"
          name="acceptTerms"
          [(ngModel)]="model.acceptTerms"
          #termsInput="ngModel"
          required>
        <label for="acceptTerms" class="checkbox-label">
          <span class="checkbox-text">
            Acepto los 
            <a href="#" target="_blank" class="terms-link">términos y condiciones</a>
            <span class="required-asterisk">*</span>
          </span>
        </label>
      </div>
      
      <div *ngIf="termsInput.invalid && termsInput.touched" class="error-messages">
        <div *ngIf="termsInput.errors?.['required']" class="error-message">
          <i class="error-icon">📋</i>
          Debe aceptar los términos y condiciones
        </div>
      </div>
    </div>

    <!-- ========== BOTONES DE ACCIÓN ========== -->
    <div class="form-actions">
      <!--
      BOTÓN LIMPIAR - RESET:
      
      1. type="button" (no submit)
      2. Llama método resetForm() pasando referencia del formulario
      3. Esto resetea tanto los datos como los estados de validación
      -->
      <button 
        type="button" 
        class="btn btn-secondary"
        (click)="resetForm(contactForm)"
        [disabled]="loading">
        <i class="btn-icon">🔄</i>
        Limpiar
      </button>
      
      <!--
      BOTÓN ENVIAR - SUBMIT:
      
      1. type="submit" ejecuta (ngSubmit) del form
      2. [disabled] con LÓGICA MÚLTIPLE:
         - contactForm.invalid: Formulario tiene errores
         - loading: Enviando actualmente (evita doble envío)
      3. Contenido dinámico según estado de loading
      4. Solo se puede clickear cuando TODO esté válido
      
      UX INTELIGENTE:
      - Deshabilitado hasta que todo sea válido
      - Muestra loading durante envío
      - Previene múltiples envíos
      -->
      <button 
        type="submit" 
        class="btn btn-primary"
        [disabled]="contactForm.invalid || loading">
        
        <!-- Contenido condicional según estado loading -->
        <span *ngIf="!loading">
          <i class="btn-icon">📤</i>
          Enviar Contacto
        </span>
        <span *ngIf="loading">
          <i class="btn-icon loading">⏳</i>
          Enviando...
        </span>
      </button>
    </div>

    <!-- ========== MENSAJE DE ESTADO ========== -->
    <!--
    FEEDBACK AL USUARIO:
    
    Muestra mensajes de éxito o error después de intentar enviar.
    Clases CSS diferentes para éxito vs error.
    -->
    <div *ngIf="statusMessage" 
         class="status-message"
         [class.success]="statusMessage.includes('✅')"
         [class.error]="statusMessage.includes('❌')">
      {{ statusMessage }}
    </div>
  </form>

  <!-- ========== INFORMACIÓN DE DEBUG (SOLO DESARROLLO) ========== -->
  <!--
  HERRAMIENTA EDUCATIVA:
  
  Esta sección ayuda a los estudiantes a entender:
  - Estados del formulario en tiempo real
  - Valores del modelo
  - Estados de validación por campo
  
  ❗ IMPORTANTE: Remover en producción
  -->
  <div *ngIf="showDebug" class="debug-panel">
    <div class="debug-header">
      <h4>🐛 Debug Info (Solo Desarrollo)</h4>
      <button (click)="toggleDebug()" class="debug-toggle">❌</button>
    </div>
    
    <div class="debug-content">
      <!-- Estados del formulario -->
      <div class="debug-section">
        <h5>📊 Estados del Formulario</h5>
        <ul class="debug-list">
          <li>Valid: <span [class]="contactForm.valid ? 'valid' : 'invalid'">{{ contactForm.valid }}</span></li>
          <li>Dirty: <span [class]="contactForm.dirty ? 'dirty' : 'pristine'">{{ contactForm.dirty }}</span></li>
          <li>Touched: <span [class]="contactForm.touched ? 'touched' : 'untouched'">{{ contactForm.touched }}</span></li>
          <li>Submitted: <span>{{ contactForm.submitted }}</span></li>
        </ul>
      </div>
      
      <!-- Valores del modelo -->
      <div class="debug-section">
        <h5>📋 Valores del Modelo</h5>
        <pre class="debug-json">{{ model | json }}</pre>
      </div>
      
      <!-- Estados por campo -->
      <div class="debug-section">
        <h5>🔍 Estados por Campo</h5>
        <div class="debug-fields">
          <div class="debug-field">
            <strong>Nombre:</strong> 
            V:{{ nameInput.valid }} | 
            T:{{ nameInput.touched }} | 
            D:{{ nameInput.dirty }}
          </div>
          <div class="debug-field">
            <strong>Email:</strong> 
            V:{{ emailInput.valid }} | 
            T:{{ emailInput.touched }} | 
            D:{{ emailInput.dirty }}
          </div>
          <!-- Agregar más campos según sea necesario -->
        </div>
      </div>
    </div>
  </div>
</div>

<!--
SIGUIENTES PASOS PARA LOS ESTUDIANTES:
=====================================

Una vez que entiendan este template, pueden:

1. 🎨 MEJORAR ESTILOS:
   - Agregar transiciones CSS
   - Mejorar responsive design  
   - Agregar iconos más atractivos

2. 📝 MÁS VALIDACIONES:
   - Validación de RUC/DNI peruano
   - Validación asíncrona de email único
   - Validaciones cruzadas entre campos

3. 🔧 FUNCIONALIDADES:
   - Autoguardado en localStorage
   - Upload de archivos adjuntos
   - Captcha para seguridad

4. 🧪 TESTING:
   - Unit tests para validaciones
   - Integration tests para envío
   - E2E tests para flujo completo

5. 🚀 MIGRACIÓN A REACTIVE FORMS:
   - Para mayor control programático
   - Validaciones más complejas
   - Better testing capabilities
-->
